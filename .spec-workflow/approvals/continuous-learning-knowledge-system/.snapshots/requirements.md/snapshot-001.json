{
  "id": "snapshot_1760808168539_1xntmil24",
  "approvalId": "approval_1760808168534_o6uprae6f",
  "approvalTitle": "Requirements Specification for Continuous Learning Knowledge System",
  "version": 1,
  "timestamp": "2025-10-18T17:22:48.539Z",
  "trigger": "initial",
  "status": "pending",
  "content": "# Requirements Specification\n**Spec Name**: `continuous-learning-knowledge-system`\n**Created**: 2025-01-18\n**Status**: Draft - Awaiting Approval\n**Budget Constraint**: $100/year LLM inference costs\n**Team Size**: 10-50 developers per team\n**Scope**: Cross-project knowledge management system hosted in \"coding\" project\n\n---\n\n## Executive Summary\n\nTransform the knowledge management system from **batch-oriented pattern storage** into a **continuous learning and trajectory-aware system** that learns from developer activity in real-time, generalizes concepts across projects, and provides proactive recommendations while respecting privacy and budget constraints.\n\n### Key Objectives\n\n1. **Continuous Learning**: Extract knowledge in real-time from development sessions, not just batch processing\n2. **Concept Generalization**: Move from storing specific patterns to learning transferable concepts\n3. **Trajectory Awareness**: Understand developer intent (learning, debugging, building) to contextualize knowledge\n4. **Cross-Project Intelligence**: Share knowledge across all projects from centralized \"coding\" hub\n5. **Budget Compliance**: Operate within $100/year using local models + strategic remote inference\n6. **Privacy-First**: Sensitive data stays local using dev container Ollama infrastructure\n7. **Agent-Agnostic**: Work with any CLI-based coding agent (Claude, Copilot, etc.)\n\n---\n\n## 1. USER STORIES\n\n### US-1: Real-Time Intent-Aware Knowledge Extraction\n**As a** developer working in a Claude Code session\n**I want** the system to understand my current intent (learning, debugging, feature development)\n**So that** knowledge extracted is contextualized with what I was trying to accomplish\n\n**Acceptance Criteria**:\n- WHEN I start a development session, the system SHALL classify my intent in real-time\n- WHEN I switch between activities (e.g., learning ‚Üí implementing), the system SHALL detect the transition\n- WHEN knowledge is extracted, it SHALL be tagged with intent context\n- WHEN I search knowledge base, I SHALL be able to filter by intent (\"show me debugging patterns\")\n- WHERE intent classification is uncertain, the system SHALL use conversation history for context\n\n**EARS Notation**:\n- WHEN a tool interaction occurs, the system SHALL extract micro-observations with intent tags\n- WHERE privacy is detected, the system SHALL use local models for classification\n- IF budget is exceeded, the system SHALL fallback to cached results or local inference\n\n### US-2: Cross-Project Pattern Discovery\n**As a** developer working across multiple projects (nano-degree, curriculum-alignment)\n**I want** to discover patterns and solutions from my other projects\n**So that** I don't repeat mistakes or reinvent solutions\n\n**Acceptance Criteria**:\n- WHEN I encounter a problem, the system SHALL search for similar patterns across all projects\n- WHEN multiple projects use the same pattern, the system SHALL generalize it into a reusable concept\n- WHEN a pattern is project-specific, it SHALL be clearly attributed\n- WHERE patterns conflict, the system SHALL explain the context differences\n- IF a deprecated pattern exists, the system SHALL warn and suggest alternatives\n\n**EARS Notation**:\n- WHEN searching knowledge base, the system SHALL return results from all projects\n- WHERE similarity threshold is met (>0.85), the system SHALL suggest pattern reuse\n- IF a newer pattern supersedes an older one, the system SHALL mark the old pattern as deprecated\n\n### US-3: Budget-Conscious Privacy-First Operations\n**As a** team lead managing infrastructure costs\n**I want** to control LLM costs while keeping sensitive code local\n**So that** we stay within budget without compromising security\n\n**Acceptance Criteria**:\n- WHEN monthly LLM costs approach $8.33 limit, the system SHALL send alerts\n- WHEN budget is exceeded, the system SHALL automatically use local models only\n- WHEN sensitive data is detected, the system SHALL route to local models regardless of budget\n- WHERE local models are unavailable, the system SHALL degrade gracefully\n- IF privacy-critical code is processed, the system SHALL log which models were used\n\n**EARS Notation**:\n- WHEN estimating token costs, the system SHALL check budget before remote inference\n- WHERE `privacy: 'local'` flag is set, the system SHALL use dev container Ollama\n- IF sensitivity is detected via LSL classification, the system SHALL override budget routing\n\n### US-4: Concept Generalization Across Teams\n**As a** developer learning from team experience\n**I want** the system to identify common patterns and generalize them\n**So that** I can apply proven solutions instead of specific examples\n\n**Acceptance Criteria**:\n- WHEN similar patterns appear 3+ times, the system SHALL create a generalized concept\n- WHEN a concept is created, it SHALL include: name, implementations, use cases, tradeoffs, pitfalls\n- WHEN I implement a pattern, the system SHALL track its effectiveness\n- WHERE a pattern frequently fails, the system SHALL downrank or deprecate it\n- IF alternative patterns exist, the system SHALL present comparisons\n\n**EARS Notation**:\n- WHEN weekly generalization workflow runs, the system SHALL cluster similar observations\n- WHERE embedding similarity exceeds 0.85, the system SHALL merge observations\n- IF semantic analysis is needed, the system SHALL use UnifiedInferenceEngine\n\n### US-5: Stale Knowledge Prevention\n**As a** developer\n**I want** to avoid using outdated patterns and technologies\n**So that** I implement current best practices, not deprecated approaches\n\n**Acceptance Criteria**:\n- WHEN knowledge hasn't been used in 90 days, it SHALL be marked as \"aging\"\n- WHEN a pattern is superseded, the system SHALL create explicit \"supersedes\" relationship\n- WHEN I search, results SHALL show freshness indicators (fresh, aging, stale, deprecated)\n- WHERE I attempt to use stale knowledge, the system SHALL warn and suggest alternatives\n- IF I query historical patterns, the system SHALL support temporal queries (\"what was used for auth in 2024?\")\n\n**EARS Notation**:\n- WHEN monthly decay detection runs, the system SHALL update freshness scores\n- WHERE last access > 90 days, the system SHALL mark knowledge as \"aging\"\n- IF a newer pattern exists, the system SHALL link via \"superseded_by\" relationship\n\n### US-6: Agent-Agnostic Compatibility\n**As a** system administrator supporting multiple coding agents\n**I want** the knowledge system to work with any CLI-based coding agent\n**So that** teams can choose their preferred tools without losing knowledge management\n\n**Acceptance Criteria**:\n- WHEN a new agent is integrated, the knowledge system SHALL work without modification\n- WHEN agents write different transcript formats, the adapter pattern SHALL normalize them\n- WHEN caching is needed, the solution SHALL be agent-agnostic (not MCP-specific)\n- WHERE agents have different capabilities, the system SHALL adapt gracefully\n- IF an agent doesn't support transcripts, the system SHALL degrade to manual knowledge entry\n\n**EARS Notation**:\n- WHEN an agent writes transcripts, the AgentAdapter SHALL normalize to common format\n- WHERE MCP Memory is unavailable, the system SHALL use generic caching layer\n- IF LSL classification is needed, the system SHALL work with any transcript source\n\n---\n\n## 2. FUNCTIONAL REQUIREMENTS\n\n### FR-1: Unified Inference Engine (Shared Code Architecture)\n**Priority**: CRITICAL\n**Component**: `src/inference/UnifiedInferenceEngine.js`\n\n**Description**: Single inference engine shared by ALL components (trajectory, learning, recommendations) to avoid duplicate code.\n\n**EARS Requirements**:\n- WHEN any component needs LLM inference, it SHALL use UnifiedInferenceEngine\n- WHERE privacy is required, the engine SHALL route to local models (Ollama in dev containers)\n- WHERE budget is available, the engine SHALL route to remote models (Groq, Anthropic)\n- IF providers fail, the engine SHALL implement circuit breaker pattern with failover\n- WHEN caching is possible, the engine SHALL cache results for 5-minute windows\n\n**Acceptance Criteria**:\n- [ ] Single `UnifiedInferenceEngine` class used by all components\n- [ ] Support for local models via Ollama (dev container integration)\n- [ ] Support for remote models (Groq primary, Anthropic fallback)\n- [ ] Provider selection based on:\n  - [ ] Privacy flag: `privacy: 'local' | 'remote' | 'auto'`\n  - [ ] Budget availability (checked via BudgetTracker)\n  - [ ] Performance requirements (fast vs accurate)\n- [ ] Caching layer with 5-minute TTL\n- [ ] Circuit breaker for failed providers (5 failures ‚Üí 1 min timeout)\n- [ ] Token counting and cost tracking\n- [ ] Reuses semantic-validator.js pattern (extend, don't duplicate)\n\n**Dependencies**:\n- BudgetTracker (FR-2)\n- LocalModelProvider (Ollama integration)\n- GroqProvider, AnthropicProvider\n\n**Integration Points**:\n- RealTimeTrajectoryAnalyzer (trajectory + intent)\n- StreamingKnowledgeExtractor (observation extraction)\n- ConceptAbstractionAgent (generalization)\n- ContextRecommender (proactive suggestions)\n\n---\n\n### FR-2: Budget Tracking and Enforcement\n**Priority**: CRITICAL\n**Component**: `src/inference/BudgetTracker.js`\n\n**Description**: Enforce $100/year budget constraint ($8.33/month) with automatic fallback.\n\n**EARS Requirements**:\n- WHEN an inference request is made, the system SHALL check budget before proceeding\n- WHERE estimated cost + used cost > monthly limit, the system SHALL deny remote inference\n- WHERE budget is exceeded, the system SHALL fallback to local models\n- IF fallback is unavailable, the system SHALL return cached results or error gracefully\n- WHEN 80% of budget is consumed, the system SHALL alert administrators\n\n**Acceptance Criteria**:\n- [ ] Track monthly LLM costs in DuckDB `budget_events` table\n- [ ] Calculate costs based on token counts: Groq (~$0.10/1M), Anthropic (~$0.25/1M)\n- [ ] Enforce monthly limit ($8.33) before allowing remote inference\n- [ ] Automatic fallback to local models when budget exceeded\n- [ ] Alert system at 80% threshold\n- [ ] Dashboard showing:\n  - [ ] Current month usage ($X.XX / $8.33)\n  - [ ] Projected end-of-month cost\n  - [ ] Cost breakdown by operation type\n  - [ ] Local vs remote inference ratio\n\n**Cost Optimization**:\n- Smart sampling (not every tool call ‚Üí only significant events)\n- Aggressive caching (deduplicate similar requests)\n- Batch processing (group observations before inference)\n- Model routing (cheap models for simple tasks, expensive for critical)\n\n**Budget Breakdown** (10-50 developers):\n- 10 developers: 500k-1M tokens/day (well within budget)\n- 50 developers: Requires >60% local inference\n\n---\n\n### FR-3: Enhanced Trajectory Understanding (Extend Existing)\n**Priority**: CRITICAL\n**Component**: `src/live-logging/RealTimeTrajectoryAnalyzer.js` (EXTEND, don't replace)\n\n**Description**: Add intent classification and concept tracking to existing trajectory analysis.\n\n**EARS Requirements**:\n- WHEN a conversation exchange occurs, the system SHALL classify BOTH trajectory state AND user intent\n- WHERE existing trajectory states apply (exploring, implementing, verifying), they SHALL be preserved\n- WHERE new intent categories apply (learning, problem-solving, feature-dev), they SHALL be added\n- IF concepts are mentioned (technologies, patterns), they SHALL be extracted and tracked\n- WHEN intents change, the system SHALL maintain context chain for continuity\n\n**Acceptance Criteria**:\n- [ ] **Existing trajectory states preserved**:\n  - [ ] `exploring` (üîç EX)\n  - [ ] `on_track` (üìà ON)\n  - [ ] `off_track` (üìâ OFF)\n  - [ ] `implementing` (‚öôÔ∏è IMP)\n  - [ ] `verifying` (‚úÖ VER)\n  - [ ] `blocked` (üö´ BLK)\n- [ ] **New intent classification added**:\n  - [ ] `learning` - Exploring/understanding codebase\n  - [ ] `problem-solving` - Debugging specific issue\n  - [ ] `feature-development` - Implementing new functionality\n  - [ ] `refactoring` - Improving existing code\n  - [ ] `knowledge-sharing` - Documenting/teaching\n  - [ ] `research` - Investigating technologies/approaches\n- [ ] **Concept extraction**: Extract entities (JWT, React, DuckDB, etc.)\n- [ ] **Goal inference**: Infer developer's goal (\"Add authentication\", \"Fix login bug\")\n- [ ] **Context chain**: Track sequence of intents within session\n- [ ] **Shared inference**: Use UnifiedInferenceEngine (not duplicate code)\n\n**Storage**:\n- Real-time state ‚Üí `.specstory/trajectory/live-state.json` (existing)\n- Historical states ‚Üí DuckDB `trajectory_history` table (new)\n- Embeddings ‚Üí Qdrant `session_intents` collection (new)\n\n**Enhanced State Schema**:\n```json\n{\n  \"currentState\": \"implementing\",\n  \"intent\": \"feature-development\",\n  \"goal\": \"Add JWT authentication\",\n  \"concepts\": [\"JWT\", \"passport.js\", \"middleware\"],\n  \"patterns_applied\": [\"middleware-pattern\"],\n  \"learning_points\": [\"JWT vs sessions tradeoff\"],\n  \"context_chain\": [\n    {\"intent\": \"research\", \"timestamp\": \"2025-01-18T10:00:00Z\"},\n    {\"intent\": \"feature-development\", \"timestamp\": \"2025-01-18T10:15:00Z\"}\n  ],\n  \"timestamp\": \"2025-01-18T10:30:00Z\",\n  \"confidence\": 0.92\n}\n```\n\n---\n\n### FR-4: Continuous Knowledge Extraction\n**Priority**: HIGH\n**Component**: `integrations/mcp-server-semantic-analysis/src/agents/streaming-knowledge-extractor.ts`\n\n**Description**: Extract knowledge in real-time from tool interactions, not just batch processing.\n\n**EARS Requirements**:\n- WHEN a tool interaction occurs (Read, Edit, Grep, Write), the system SHALL extract micro-observations\n- WHERE observations are related, the system SHALL buffer them for clustering\n- WHERE buffer reaches threshold (10 observations OR 5 minutes), the system SHALL flush to knowledge base\n- IF insights can be generated, the system SHALL create provisional insights\n- WHEN privacy is detected, the system SHALL use local models for extraction\n\n**Acceptance Criteria**:\n- [ ] Subscribe to tool-interaction-hook events (existing PostToolUse hook)\n- [ ] Extract micro-observations:\n  - [ ] **Search patterns**: \"User searched for X pattern\" (from Grep/Glob)\n  - [ ] **Implementation patterns**: \"User implemented Y solution\" (from Edit/Write)\n  - [ ] **Blockers**: \"User blocked on A when doing B\" (from error patterns)\n  - [ ] **Constraints**: \"Constraint X fired, user wanted Y\" (from constraint-monitor)\n  - [ ] **Intent context**: Tag observations with current intent\n- [ ] Buffer observations in KnowledgeStreamBuffer\n- [ ] Flush triggers:\n  - [ ] 10 observations accumulated\n  - [ ] 5 minutes elapsed\n  - [ ] Session ends\n- [ ] Cluster related observations using semantic similarity\n- [ ] Generate provisional insights via UnifiedInferenceEngine\n- [ ] Store in databases (Qdrant + DuckDB)\n\n**Integration Points**:\n- Tool interaction hooks (existing)\n- RealTimeTrajectoryAnalyzer (get current intent)\n- ObservationGenerationAgent (existing, feed observations)\n- DatabaseManager (Qdrant + DuckDB storage)\n\n**Performance**:\n- Async buffering (non-blocking for developer)\n- Batch processing (reduce LLM calls)\n- Cache frequently seen patterns\n\n---\n\n### FR-5: Database Architecture (Replace JSON)\n**Priority**: CRITICAL\n**Component**: `src/databases/DatabaseManager.js`\n\n**Description**: Migrate from JSON files to Qdrant (vectors) + DuckDB (temporal analytics).\n\n**EARS Requirements**:\n- WHERE knowledge has embeddings, it SHALL be stored in Qdrant for semantic search\n- WHERE knowledge has temporal aspects, it SHALL be stored in DuckDB for time-series queries\n- WHERE real-time access is needed, caching layer SHALL serve frequently accessed data\n- IF databases are unavailable, the system SHALL degrade gracefully (read-only mode)\n- WHEN VKB visualization is requested, it SHALL read from databases (not JSON)\n\n**Database Assignments**:\n\n**Qdrant (Vector/Semantic Search)**:\n- [ ] Collection: `knowledge_concepts`\n  - Purpose: Generalized concept embeddings\n  - Model: Larger embedding model (1024-dim for better semantic understanding)\n  - Fields: concept_name, description, implementations[], use_cases[], tradeoffs[], embeddings\n- [ ] Collection: `code_patterns`\n  - Purpose: Specific code pattern embeddings\n  - Model: 384-dim (fast, existing sentence-transformers/all-MiniLM-L6-v2)\n  - Fields: pattern_name, code_snippet, project, language, embeddings\n- [ ] Collection: `session_intents`\n  - Purpose: Historical intent classifications\n  - Model: 384-dim (fast classification)\n  - Fields: session_id, intent, trajectory, concepts[], timestamp, embeddings\n- [ ] Collection: `recommendations`\n  - Purpose: Recommendation effectiveness tracking\n  - Model: 384-dim\n  - Fields: recommendation_id, was_followed, outcome, context, embeddings\n\n**DuckDB (Temporal/Analytical Queries)**:\n```sql\n-- Knowledge events (all changes over time)\nCREATE TABLE knowledge_events (\n  id UUID PRIMARY KEY,\n  timestamp TIMESTAMP NOT NULL,\n  event_type VARCHAR NOT NULL, -- created, modified, accessed, deprecated, superseded\n  entity_id VARCHAR NOT NULL,\n  entity_type VARCHAR NOT NULL, -- concept, pattern, observation, recommendation\n  project VARCHAR NOT NULL,\n  confidence FLOAT,\n  metadata JSON -- flexible storage for event-specific data\n);\n\n-- Trajectory history (session states over time)\nCREATE TABLE trajectory_history (\n  id UUID PRIMARY KEY,\n  timestamp TIMESTAMP NOT NULL,\n  session_id VARCHAR NOT NULL,\n  project VARCHAR NOT NULL,\n  trajectory_state VARCHAR NOT NULL,\n  intent VARCHAR NOT NULL,\n  concepts JSON, -- array of concepts\n  goal TEXT,\n  confidence FLOAT,\n  metadata JSON\n);\n\n-- Budget tracking\nCREATE TABLE budget_events (\n  id UUID PRIMARY KEY,\n  timestamp TIMESTAMP NOT NULL,\n  operation_type VARCHAR NOT NULL,\n  provider VARCHAR NOT NULL, -- groq, anthropic, local\n  tokens_used INTEGER NOT NULL,\n  cost_usd DECIMAL(10, 4),\n  project VARCHAR,\n  metadata JSON\n);\n\n-- Pattern effectiveness (success tracking)\nCREATE TABLE pattern_effectiveness (\n  id UUID PRIMARY KEY,\n  pattern_id VARCHAR NOT NULL,\n  applied_timestamp TIMESTAMP NOT NULL,\n  outcome VARCHAR, -- success, failure, abandoned\n  session_id VARCHAR,\n  project VARCHAR,\n  effectiveness_score FLOAT,\n  metadata JSON\n);\n\n-- Indexes for performance\nCREATE INDEX idx_knowledge_time ON knowledge_events(timestamp);\nCREATE INDEX idx_knowledge_entity ON knowledge_events(entity_id);\nCREATE INDEX idx_trajectory_time ON trajectory_history(timestamp);\nCREATE INDEX idx_trajectory_session ON trajectory_history(session_id);\nCREATE INDEX idx_budget_time ON budget_events(timestamp);\nCREATE INDEX idx_budget_provider ON budget_events(provider);\nCREATE INDEX idx_effectiveness_time ON pattern_effectiveness(applied_timestamp);\n```\n\n**Migration Strategy**:\n- [ ] One-time bulk migration from `shared-memory-*.json` to databases\n- [ ] Migration script: `scripts/migrate-json-to-databases.js`\n- [ ] Validation: Compare before/after counts, spot-check samples\n- [ ] VKB visualization adapted to read from Qdrant + DuckDB\n- [ ] Backward compatibility during transition (dual-read for 1 month)\n- [ ] Decommission JSON files after validation\n\n**VKB Visualization Adaptation**:\n- [ ] Read nodes from Qdrant (concepts, patterns)\n- [ ] Read relationships from DuckDB (temporal edges)\n- [ ] Read freshness scores from DuckDB (last_accessed)\n- [ ] Format nodes per database schema (not JSON structure)\n- [ ] Maintain visual hierarchy: Specific ‚Üí Pattern ‚Üí Concept ‚Üí Principle\n\n---\n\n### FR-6: Privacy-Aware Classification (Reuse LSL 5-Layer System)\n**Priority**: CRITICAL\n**Component**: `src/knowledge-management/SensitivityClassifier.js`\n\n**Description**: Reuse LSL 5-layer classification system to detect sensitive topics and route to local models.\n\n**EARS Requirements**:\n- WHEN content needs classification, the system SHALL use existing LSL classification layers\n- WHERE sensitivity configuration defines sensitive topics, the system SHALL detect them\n- WHERE sensitivity is detected, the system SHALL override all routing to use local models\n- IF local models unavailable, the system SHALL fail-safe (no remote inference for sensitive data)\n- WHEN sensitivity is detected, the system SHALL log the decision for audit\n\n**Reuse LSL 5-Layer Classification**:\n\nLayers (from LSL documentation):\n0. **SessionFilter** (pre-filter): Session continuation detection\n1. **PathClassifier**: File path-based detection\n2. **KeywordClassifier**: Keyword/term matching (<10ms)\n3. **EmbeddingClassifier**: Semantic similarity (384-dim, ~50ms)\n4. **SemanticAnalyzer**: LLM-powered deep understanding (<10ms with caching)\n\n**Sensitivity Adaptation**:\n```javascript\n// Configuration: .specstory/config/sensitivity-topics.json\n{\n  \"sensitive_topics\": [\n    {\n      \"name\": \"credentials\",\n      \"keywords\": [\"API_KEY\", \"password\", \"secret\", \"token\", \"credentials\"],\n      \"paths\": [\"**/config/secrets/**\", \"**/.env\"],\n      \"embedding_threshold\": 0.75\n    },\n    {\n      \"name\": \"proprietary_algorithms\",\n      \"keywords\": [\"proprietary\", \"patent\", \"trade secret\"],\n      \"paths\": [\"**/core/algorithms/**\"],\n      \"embedding_threshold\": 0.80\n    },\n    {\n      \"name\": \"customer_data\",\n      \"keywords\": [\"PII\", \"SSN\", \"credit card\", \"personal data\"],\n      \"embedding_threshold\": 0.85\n    }\n  ],\n  \"default_action\": \"local_only\"\n}\n```\n\n**Classification Process**:\n1. Run PathClassifier (check file paths against sensitivity config)\n2. Run KeywordClassifier (check for sensitive keywords)\n3. If uncertain, run EmbeddingClassifier (semantic similarity to sensitive topics)\n4. If still uncertain, run SemanticAnalyzer (LLM classification)\n5. If ANY layer detects sensitivity ‚Üí route to local models\n\n**Acceptance Criteria**:\n- [ ] Reuse existing LSL classification infrastructure (no duplication)\n- [ ] Configuration-driven sensitivity detection\n- [ ] Layer-based detection (fast ‚Üí expensive progression)\n- [ ] Audit logging of sensitivity decisions\n- [ ] Override routing: sensitivity ‚Üí local models always\n- [ ] Fail-safe: no remote inference if local unavailable\n\n---\n\n### FR-7: Agent-Agnostic Caching (Replace MCP Memory)\n**Priority**: HIGH\n**Component**: `src/caching/AgentAgnosticCache.js`\n\n**Description**: Replace MCP Memory server with generic caching solution compatible with any coding agent.\n\n**EARS Requirements**:\n- WHEN any agent needs caching, the cache SHALL work regardless of agent type\n- WHERE MCP Memory was used, the new cache SHALL provide equivalent functionality\n- WHERE agents don't support MCP, the cache SHALL work via file-based or HTTP API\n- IF cache is unavailable, the system SHALL fallback to direct database queries\n- WHEN cache is hit, the system SHALL avoid redundant LLM calls\n\n**Acceptance Criteria**:\n- [ ] **Multi-backend support**:\n  - [ ] File-based cache (universal compatibility)\n  - [ ] HTTP API (for programmatic access)\n  - [ ] MCP protocol (for MCP-compatible agents)\n- [ ] **Cache Operations**:\n  - [ ] `set(key, value, ttl)` - Store with TTL\n  - [ ] `get(key)` - Retrieve cached value\n  - [ ] `invalidate(key)` - Force refresh\n  - [ ] `search(query)` - Semantic search in cache\n- [ ] **Performance**:\n  - [ ] In-memory cache for hot data (LRU eviction)\n  - [ ] Disk persistence for cold data\n  - [ ] 5-minute default TTL (configurable)\n  - [ ] Cache hit rate > 40%\n- [ ] **Agent Adapters**:\n  - [ ] ClaudeAdapter (MCP + file-based)\n  - [ ] CopilotAdapter (HTTP API)\n  - [ ] GenericAdapter (file-based fallback)\n\n**Cache Structure**:\n```javascript\n{\n  \"cache_entries\": {\n    \"intent_classification_{hash}\": {\n      \"value\": {\"intent\": \"feature-development\", \"confidence\": 0.92},\n      \"timestamp\": \"2025-01-18T10:30:00Z\",\n      \"ttl\": 300, // 5 minutes\n      \"hits\": 12\n    },\n    \"pattern_search_{hash}\": {\n      \"value\": [/* Qdrant results */],\n      \"timestamp\": \"2025-01-18T10:25:00Z\",\n      \"ttl\": 300,\n      \"hits\": 3\n    }\n  },\n  \"statistics\": {\n    \"total_requests\": 1523,\n    \"cache_hits\": 687,\n    \"cache_misses\": 836,\n    \"hit_rate\": 0.451\n  }\n}\n```\n\n**Migration from MCP Memory**:\n- [ ] Identify all MCP Memory calls in current codebase\n- [ ] Replace with AgentAgnosticCache calls\n- [ ] Maintain backward compatibility (MCP backend still available)\n- [ ] Test with multiple agent types (Claude, hypothetical others)\n\n---\n\n### FR-8: Concept Generalization\n**Priority**: HIGH\n**Component**: `integrations/mcp-server-semantic-analysis/src/agents/concept-abstraction-agent.ts`\n\n**Description**: Generalize specific patterns into reusable concepts across projects.\n\n**EARS Requirements**:\n- WHEN similar observations occur 3+ times, the system SHALL create a generalized concept\n- WHERE observations share semantic similarity >0.85, the system SHALL group them\n- WHERE generalization is possible, the system SHALL use UnifiedInferenceEngine\n- IF privacy is detected, the system SHALL use local models for generalization\n- WHEN a concept is created, the system SHALL store in Qdrant with full context\n\n**Acceptance Criteria**:\n- [ ] Weekly batch generalization workflow\n- [ ] Group similar observations using Qdrant semantic search (>0.85 similarity)\n- [ ] Generate generalized concepts via LLM:\n  - [ ] Concept name (e.g., \"Stateless Authentication Pattern\")\n  - [ ] Implementations (e.g., JWT, OAuth2, SAML)\n  - [ ] When to use (e.g., APIs, microservices, mobile apps)\n  - [ ] Tradeoffs (e.g., stateless vs database sessions)\n  - [ ] Common pitfalls (e.g., token expiration handling)\n  - [ ] Related concepts (e.g., Session Management, RBAC)\n- [ ] Create hierarchy in Qdrant:\n  - Specific observation ‚Üí Pattern ‚Üí Concept ‚Üí Principle\n- [ ] Deduplicate using enhanced DeduplicationAgent\n- [ ] Store embeddings (1024-dim for better semantic understanding)\n\n**Example Transformation**:\n```\nINPUT (Observations):\n- \"Used JWT for API auth in nano-degree project\"\n- \"Implemented passport.js with JWT in curriculum-alignment\"\n- \"OAuth2 flow for third-party API in coding project\"\n\nOUTPUT (Generalized Concept):\n{\n  \"name\": \"Stateless Authentication Pattern\",\n  \"description\": \"Authentication approach that doesn't maintain server-side session state\",\n  \"implementations\": [\n    {\"name\": \"JWT\", \"use_case\": \"Stateless API authentication\", \"complexity\": \"low\"},\n    {\"name\": \"OAuth2\", \"use_case\": \"Third-party authorization\", \"complexity\": \"medium\"},\n    {\"name\": \"SAML\", \"use_case\": \"Enterprise SSO\", \"complexity\": \"high\"}\n  ],\n  \"when_to_use\": [\n    \"Microservices architectures\",\n    \"Mobile app backends\",\n    \"Stateless APIs\",\n    \"Distributed systems\"\n  ],\n  \"tradeoffs\": {\n    \"pros\": [\"No server-side state\", \"Scales horizontally\", \"Language-agnostic\"],\n    \"cons\": [\"Token size overhead\", \"Harder to invalidate\", \"Expiration complexity\"]\n  },\n  \"common_pitfalls\": [\n    \"Not handling token refresh properly\",\n    \"Storing tokens insecurely (localStorage XSS)\",\n    \"Not validating token signatures\"\n  ],\n  \"related_concepts\": [\"Session Management\", \"RBAC\", \"API Security\"],\n  \"confidence\": 0.91,\n  \"projects\": [\"nano-degree\", \"curriculum-alignment\", \"coding\"]\n}\n```\n\n---\n\n### FR-9: Temporal Knowledge Management\n**Priority**: MEDIUM\n**Component**: `src/knowledge-management/KnowledgeDecayTracker.js`\n\n**Description**: Track knowledge freshness and prevent stale recommendations.\n\n**EARS Requirements**:\n- WHEN knowledge hasn't been accessed in 30 days, the system SHALL mark it as \"aging\"\n- WHEN knowledge hasn't been accessed in 90 days, the system SHALL mark it as \"stale\"\n- WHERE a pattern is superseded, the system SHALL create explicit relationship\n- WHERE temporal queries are made, the system SHALL use DuckDB for efficient time-series access\n- IF stale knowledge is recommended, the system SHALL warn the user\n\n**Acceptance Criteria**:\n- [ ] **Freshness States**:\n  - [ ] `fresh` - accessed/validated in last 30 days\n  - [ ] `aging` - not accessed in 30-90 days\n  - [ ] `stale` - not accessed in 90+ days\n  - [ ] `deprecated` - explicitly superseded by newer pattern\n- [ ] **Temporal Relationships** (stored in Qdrant payload):\n  - [ ] `supersedes` - pattern B replaced pattern A\n  - [ ] `evolved_from` - pattern B is refined version of A\n  - [ ] `valid_from` / `valid_until` - time bounds for applicability\n- [ ] **Monthly Decay Detection**:\n  - [ ] Query DuckDB for last access timestamps\n  - [ ] Update freshness scores in Qdrant\n  - [ ] Create deprecation links where applicable\n- [ ] **Search Prioritization**:\n  - [ ] Fresh knowledge ranked higher\n  - [ ] Aging knowledge shown with warning\n  - [ ] Stale knowledge requires explicit selection\n  - [ ] Deprecated knowledge shows \"superseded by\" link\n- [ ] **Temporal Queries** (DuckDB):\n  ```sql\n  -- What patterns were used for authentication in 2024?\n  SELECT DISTINCT entity_id, metadata\n  FROM knowledge_events\n  WHERE entity_type = 'pattern'\n    AND metadata->>'category' = 'authentication'\n    AND timestamp BETWEEN '2024-01-01' AND '2024-12-31'\n    AND event_type = 'created';\n  ```\n\n---\n\n## 3. NON-FUNCTIONAL REQUIREMENTS\n\n### NFR-1: Performance\n**Priority**: HIGH\n\n**EARS Requirements**:\n- WHEN real-time operations are requested, the system SHALL respond within defined latency bounds\n- WHERE performance degrades, the system SHALL log metrics for investigation\n- IF performance SLAs are violated, the system SHALL alert administrators\n\n**Acceptance Criteria**:\n- [ ] **Real-Time Trajectory/Intent Classification**: < 2s (p95)\n- [ ] **Knowledge Query Response**: < 500ms (p95)\n- [ ] **Observation Buffering**: Async, non-blocking for developer\n- [ ] **Qdrant Queries**: < 100ms (p95)\n- [ ] **DuckDB Analytical Queries**: < 1s (p95)\n- [ ] **Cache Hit Rate**: > 40% (reduces LLM calls)\n- [ ] **LLM Inference** (cached): < 50ms\n- [ ] **LLM Inference** (uncached remote): < 3s\n- [ ] **LLM Inference** (uncached local): < 5s (Ollama in dev container)\n\n**Performance Monitoring**:\n- [ ] Dashboard showing p50, p95, p99 latencies\n- [ ] Alerts for SLA violations\n- [ ] Performance regression detection\n\n---\n\n### NFR-2: Scalability\n**Priority**: HIGH\n\n**EARS Requirements**:\n- WHEN 10-50 developers are active, the system SHALL maintain performance\n- WHERE load increases, the system SHALL scale horizontally (Qdrant clustering)\n- IF concurrent requests exceed capacity, the system SHALL queue gracefully\n\n**Acceptance Criteria**:\n- [ ] **Concurrent Developer Support**: 10-50 developers per team\n- [ ] **Qdrant Performance**: 100+ QPS (already optimized with HNSW + int8 quantization)\n- [ ] **DuckDB Concurrency**: Support concurrent reads (analytical queries)\n- [ ] **Inference Queue**: Prevent provider overload (max 10 concurrent remote calls)\n- [ ] **Cache Sharing**: Distributed cache for multi-developer environments\n- [ ] **Horizontal Scaling**: Qdrant clustering for future growth (>50 developers)\n\n**Load Testing**:\n- Simulate 50 concurrent developers\n- Verify latency SLAs maintained\n- Identify bottlenecks\n\n---\n\n### NFR-3: Cost Efficiency\n**Priority**: CRITICAL\n\n**EARS Requirements**:\n- WHEN monthly costs approach $8.33, the system SHALL enforce strict limits\n- WHERE local inference is possible, the system SHALL prefer it for cost savings\n- IF budget is exceeded, the system SHALL block remote inference until next month\n\n**Acceptance Criteria**:\n- [ ] **Monthly Budget**: Strict $8.33/month limit ($100/year)\n- [ ] **Token Usage**: < 2.7M tokens/day (averaged monthly)\n- [ ] **Local vs Remote Ratio**: > 60% local inference\n- [ ] **Smart Sampling**: Only analyze significant events (not every tool call)\n- [ ] **Aggressive Caching**: 40%+ hit rate\n- [ ] **Batch Processing**: Group observations to reduce LLM calls\n- [ ] **Model Routing**:\n  - Groq llama-3.3-70b: Trajectory, intent (~$0.10/1M tokens)\n  - Groq qwen-2.5-32b: Cheap pattern extraction (~$0.05/1M tokens)\n  - Local Ollama: Privacy-critical, bulk operations (~$0/1M tokens)\n  - Anthropic Haiku: Fallback only (~$0.25/1M tokens)\n\n**Cost Reporting**:\n- Monthly cost dashboard\n- Projected end-of-month estimate\n- Cost breakdown by operation type\n- Alert at 80% threshold\n\n---\n\n### NFR-4: Privacy & Security\n**Priority**: CRITICAL\n\n**EARS Requirements**:\n- WHEN sensitive data is detected, the system SHALL route to local models only\n- WHERE privacy flag is set, the system SHALL never use remote inference\n- IF audit is requested, the system SHALL provide complete history of inference routing\n\n**Acceptance Criteria**:\n- [ ] **Sensitivity Detection**: Reuse LSL 5-layer classification with sensitive topics config\n- [ ] **Privacy Routing**:\n  - `privacy: 'local'` ‚Üí Ollama in dev container (no remote calls)\n  - `privacy: 'remote'` ‚Üí Remote models allowed (budget permitting)\n  - `privacy: 'auto'` ‚Üí Automatic detection via sensitivity classifier\n- [ ] **Local Model Support**: Ollama in AWS dev containers (CODER infrastructure)\n- [ ] **Audit Logging**: All remote LLM calls logged with content hash (not content)\n- [ ] **Fail-Safe**: If local models unavailable for sensitive data, fail (no remote fallback)\n- [ ] **Sensitive Topics Config**: `.specstory/config/sensitivity-topics.json`\n\n**Privacy Compliance**:\n- No sensitive code sent to remote LLMs\n- Audit trail for compliance verification\n- User transparency (know what goes remote)\n\n---\n\n### NFR-5: Reliability\n**Priority**: HIGH\n\n**EARS Requirements**:\n- WHEN components fail, the system SHALL degrade gracefully without blocking development\n- WHERE critical services are down, the system SHALL retry with exponential backoff\n- IF all providers fail, the system SHALL return cached results or skip analysis\n\n**Acceptance Criteria**:\n- [ ] **Graceful Degradation**: LLM failures don't block development\n- [ ] **Circuit Breakers**: 5 failures ‚Üí 1 minute timeout\n- [ ] **Fallback Hierarchy**:\n  1. Remote LLM (Groq)\n  2. Remote LLM (Anthropic)\n  3. Local LLM (Ollama)\n  4. Cached results\n  5. Skip analysis (continue working)\n- [ ] **Database Resilience**: Connection pooling, automatic retry\n- [ ] **Health Checks**: Monitor all components (LSL pattern)\n- [ ] **Automatic Recovery**: Restart failed processes (Global Service Coordinator pattern)\n\n**Monitoring**:\n- Service health dashboard\n- Error rate tracking\n- Automatic alerting\n\n---\n\n### NFR-6: Maintainability\n**Priority**: MEDIUM\n\n**EARS Requirements**:\n- WHEN developers need to understand the system, documentation SHALL be comprehensive\n- WHERE code is duplicated, it SHALL be refactored into shared components\n- IF changes are needed, the system SHALL be modular and loosely coupled\n\n**Acceptance Criteria**:\n- [ ] **No Code Duplication**: UnifiedInferenceEngine shared by all components\n- [ ] **Clear Separation**: Inference, Storage, Analysis as separate modules\n- [ ] **Configuration-Driven**: Local vs remote routing via config, not code\n- [ ] **Comprehensive Logging**: All decisions logged with reasoning\n- [ ] **Metrics Dashboard**: Cost, performance, freshness, effectiveness\n- [ ] **Documentation**: Architecture diagrams, API contracts, integration guides\n- [ ] **Testing**: Unit tests, integration tests, load tests\n\n**Code Quality**:\n- TypeScript for type safety\n- ESLint/Prettier for consistency\n- Code review for all changes\n\n---\n\n## 4. TECHNICAL CONSTRAINTS\n\n### TC-1: Reuse Existing Infrastructure\n**Constraint**: Must extend existing systems, not replace them\n\n**Impacts**:\n- [ ] Extend `RealTimeTrajectoryAnalyzer` (add intent, don't replace trajectory)\n- [ ] Reuse `semantic-validator.js` pattern ‚Üí `UnifiedInferenceEngine`\n- [ ] Keep existing MCP agents (GitHistoryAgent, VibeHistoryAgent, etc.)\n- [ ] Maintain LSL system compatibility (5-layer classification)\n- [ ] Preserve VKB visualization (adapt to read from databases)\n\n### TC-2: Database Technology Fixed\n**Constraint**: Qdrant (vectors) + DuckDB (temporal) only\n\n**Rationale**:\n- Qdrant already integrated and optimized\n- DuckDB perfect for temporal analytics, embedded (no server)\n- No PostgreSQL, MongoDB, or other databases\n\n**Impacts**:\n- [ ] All vector operations use Qdrant\n- [ ] All time-series queries use DuckDB\n- [ ] Migration from JSON must target these databases\n\n### TC-3: Local Model Infrastructure\n**Constraint**: Ollama in AWS dev containers (CODER)\n\n**Rationale**:\n- Dev containers already include Ollama\n- Centralized deployment for teams\n- GPU acceleration available\n\n**Impacts**:\n- [ ] Local models accessed via Ollama API\n- [ ] Dev container health checks required\n- [ ] Network latency to dev containers acceptable (<100ms)\n\n### TC-4: Agent-Agnostic Design\n**Constraint**: Must work with ANY CLI-based coding agent\n\n**Rationale**:\n- Project \"coding\" is not Claude-specific\n- Teams may use different agents\n- Future-proof for new agent technologies\n\n**Impacts**:\n- [ ] No MCP-specific dependencies (replace MCP Memory)\n- [ ] Generic transcript format (AgentAdapter pattern)\n- [ ] File-based or HTTP API caching (not just MCP)\n- [ ] Documentation for integrating new agents\n\n### TC-5: Cross-Project Operation\n**Constraint**: Coding hosts system, all projects use it\n\n**Rationale**:\n- Centralized knowledge management\n- Shared learning across projects\n- Consistent infrastructure\n\n**Impacts**:\n- [ ] Knowledge tagged by project\n- [ ] VKB teams concept preserved (domain-specific knowledge bases)\n- [ ] Cross-project queries supported\n- [ ] Attribution to source project\n\n---\n\n## 5. INTEGRATION REQUIREMENTS\n\n### INT-1: Real-Time Trajectory System\n**Integration Point**: `src/live-logging/RealTimeTrajectoryAnalyzer.js`\n\n**Requirements**:\n- [ ] Share `UnifiedInferenceEngine` (no duplicate inference code)\n- [ ] Add intent classification (preserve trajectory states)\n- [ ] Store enhanced states in DuckDB\n- [ ] Embeddings in Qdrant\n- [ ] Maintain existing status line integration\n\n### INT-2: MCP Semantic Analysis\n**Integration Point**: `integrations/mcp-server-semantic-analysis/`\n\n**Requirements**:\n- [ ] Add `StreamingKnowledgeExtractor` agent\n- [ ] Extend `ConceptAbstractionAgent` with generalization\n- [ ] Use existing `DeduplicationAgent` with Qdrant similarity\n- [ ] Preserve existing workflow orchestration (CoordinatorAgent)\n\n### INT-3: Constraint Monitor\n**Integration Point**: `integrations/mcp-constraint-monitor/`\n\n**Requirements**:\n- [ ] Feed violation data to knowledge extraction\n- [ ] Use violations as learning signals (\"user wanted X but violated Y\")\n- [ ] Integrate with budget tracker (shared cost pool)\n- [ ] Reuse Qdrant client (already integrated)\n\n### INT-4: LSL System\n**Integration Point**: `scripts/enhanced-transcript-monitor.js`\n\n**Requirements**:\n- [ ] Tool interaction hooks feed `StreamingKnowledgeExtractor`\n- [ ] Session logs analyzed for long-term patterns\n- [ ] Cross-project session analysis (existing redirect detection)\n- [ ] Reuse 5-layer classification for sensitivity detection\n\n### INT-5: VKB/UKB Commands\n**Integration Point**: `bin/vkb`, `bin/ukb`\n\n**Requirements**:\n- [ ] `vkb` visualize knowledge graph (read from Qdrant + DuckDB, not JSON)\n- [ ] `ukb` update knowledge base (trigger workflows)\n- [ ] Dashboard shows real-time metrics (cost, performance, freshness)\n- [ ] Preserve existing CLI interface (no breaking changes)\n\n---\n\n## 6. SUCCESS METRICS\n\n### Knowledge Quality Metrics\n- [ ] **Abstraction Ratio**: Generalized concepts / Total observations (target: > 0.3)\n- [ ] **Reuse Rate**: Patterns recommended and applied (target: > 40%)\n- [ ] **Freshness Score**: % knowledge validated in last 90 days (target: > 70%)\n- [ ] **Deduplication Rate**: Similar concepts merged (target: > 85%)\n- [ ] **Concept Hierarchy Depth**: Average depth of concept abstraction (target: 3-4 levels)\n\n### Developer Experience Metrics\n- [ ] **Time to Insight**: Query to answer (target: < 30s)\n- [ ] **Cache Hit Rate**: Reduced redundant LLM calls (target: > 40%)\n- [ ] **Recommendation Acceptance**: Developers follow suggestions (target: > 30%)\n- [ ] **Session Continuity**: Context preserved across sessions (target: > 90%)\n\n### System Performance Metrics\n- [ ] **Trajectory Classification Latency**: < 2s (p95)\n- [ ] **Knowledge Query Latency**: < 500ms (p95)\n- [ ] **Database Query Performance**: Qdrant < 100ms, DuckDB < 1s (p95)\n- [ ] **System Uptime**: > 99.5% (LSL monitoring ensures reliability)\n\n### Cost Metrics\n- [ ] **Monthly LLM Spend**: < $8.33/month (strict limit, no exceptions)\n- [ ] **Token Usage**: < 2.7M tokens/day (averaged monthly)\n- [ ] **Local vs Remote Ratio**: > 60% local inference\n- [ ] **Cost Per Developer**: < $0.17/month (at 50 developers)\n\n---\n\n## 7. RISKS & MITIGATION\n\n### RISK-1: LLM Budget Overrun\n**Probability**: MEDIUM\n**Impact**: HIGH (blocks all remote inference)\n\n**Mitigation**:\n- [ ] Strict budget enforcement via BudgetTracker\n- [ ] Automatic fallback to local models (Ollama)\n- [ ] Aggressive caching (40%+ hit rate target)\n- [ ] Smart sampling (only significant events)\n- [ ] Monthly cost alerts at 80% threshold\n\n### RISK-2: Local Model Performance\n**Probability**: MEDIUM\n**Impact**: MEDIUM (slower inference times)\n\n**Mitigation**:\n- [ ] Use fast local models (Qwen 2.5 32B, LLaMA 3.3 70B)\n- [ ] GPU acceleration in dev containers\n- [ ] Batch processing for bulk operations\n- [ ] Async inference (non-blocking)\n- [ ] Cache local model results aggressively\n\n### RISK-3: Database Performance Degradation\n**Probability**: LOW\n**Impact**: HIGH (slow knowledge queries)\n\n**Mitigation**:\n- [ ] Qdrant already optimized (HNSW + int8 quantization)\n- [ ] DuckDB indexes on temporal columns\n- [ ] Regular database maintenance (vacuum, analyze)\n- [ ] Query optimization (limit result sets, use indexes)\n- [ ] Monitor query performance (alert on slow queries)\n\n### RISK-4: Knowledge Quality Decline\n**Probability**: MEDIUM\n**Impact**: MEDIUM (bad recommendations)\n\n**Mitigation**:\n- [ ] QA agent validation (existing, from semantic analysis)\n- [ ] Manual review dashboard\n- [ ] Feedback loop (track recommendation effectiveness)\n- [ ] Decay detection (remove stale knowledge)\n- [ ] Human-in-the-loop for critical concepts\n\n### RISK-5: Privacy Breach\n**Probability**: LOW\n**Impact**: CRITICAL (sensitive data leaked)\n\n**Mitigation**:\n- [ ] Sensitivity detection via LSL 5-layer classification\n- [ ] Fail-safe: no remote inference for sensitive data\n- [ ] Audit logging (all remote calls tracked)\n- [ ] Manual review of sensitive topic configuration\n- [ ] Regular privacy audits\n\n---\n\n## 8. OPEN QUESTIONS (RESOLVED)\n\n### Q1: Embedding Model\n**Question**: Which model for generating embeddings?\n- Option A: sentence-transformers/all-MiniLM-L6-v2 (384-dim, fast)\n- Option B: Larger model for better semantic understanding\n\n**Resolution**:\n- **1024-dim model for knowledge concepts** (better semantic understanding, worth the cost)\n- **384-dim model for fast operations** (pattern matching, intent classification)\n- Rationale: Balance accuracy vs speed based on use case\n\n### Q2: Local Model Deployment\n**Question**: How to deploy local models for teams?\n- Option A: Each developer runs Ollama locally\n- Option B: Shared local inference server per team\n\n**Resolution**:\n- **Dev containers with Ollama in CODER/AWS infrastructure**\n- Already deployed, GPU acceleration available\n- Centralized management, consistent environment\n\n### Q3: Migration Strategy\n**Question**: How to migrate existing JSON knowledge base?\n- Option A: One-time bulk migration\n- Option B: Gradual migration (dual-write during transition)\n\n**Resolution**:\n- **One-time bulk migration**\n- Ensure VKB visualization adapted to read from databases (not JSON)\n- Node format adapted to database table fields\n- Validation before decommissioning JSON files\n\n### Q4: Privacy Detection\n**Question**: How to automatically detect sensitive data?\n- Option A: Regex patterns (API keys, credentials)\n- Option B: LLM-based classification\n- Option C: Manual tagging\n\n**Resolution**:\n- **Reuse LSL 5-layer classification system**\n- Configuration-driven sensitive topics (`.specstory/config/sensitivity-topics.json`)\n- Progressive detection: Path ‚Üí Keyword ‚Üí Embedding ‚Üí Semantic ‚Üí LLM\n- Same proven approach as existing LSL classification\n\n### Q5: MCP Memory Replacement\n**Question**: How to replace MCP Memory for agent-agnostic compatibility?\n\n**Resolution**:\n- **Create AgentAgnosticCache.js**\n- Multi-backend support: File-based (universal), HTTP API (programmatic), MCP (compatibility)\n- Generic interface works with any CLI-based coding agent\n- Maintains MCP backend for Claude compatibility\n\n---\n\n## 9. IMPLEMENTATION PHASES\n\n### Phase 1: Unified Infrastructure (Weeks 1-2)\n**Goal**: Build shared foundation, no duplicate code\n\n**Components**:\n- [ ] `UnifiedInferenceEngine.js` - Shared LLM inference (extends semantic-validator pattern)\n- [ ] `BudgetTracker.js` - Cost enforcement ($8.33/month limit)\n- [ ] `DatabaseManager.js` - Qdrant + DuckDB integration\n- [ ] `AgentAgnosticCache.js` - Replace MCP Memory\n- [ ] `SensitivityClassifier.js` - Reuse LSL 5-layer classification\n\n**Integration**:\n- Wire UnifiedInferenceEngine into RealTimeTrajectoryAnalyzer\n- Test budget enforcement with mock LLM calls\n- Validate Qdrant + DuckDB connectivity\n\n**Success Criteria**:\n- All components use UnifiedInferenceEngine (no duplicate inference code)\n- Budget tracking working (test with small limit)\n- Databases accessible and performant\n\n---\n\n### Phase 2: Enhanced Trajectory & Intent (Weeks 3-4)\n**Goal**: Add intent classification to existing trajectory system\n\n**Components**:\n- [ ] Extend `RealTimeTrajectoryAnalyzer` (preserve existing trajectory states)\n- [ ] Add intent classification (learning, debugging, feature-dev, etc.)\n- [ ] Concept extraction from conversation\n- [ ] Goal inference\n- [ ] Context chain tracking\n\n**Storage**:\n- [ ] Real-time: `.specstory/trajectory/live-state.json` (enhanced schema)\n- [ ] Historical: DuckDB `trajectory_history` table\n- [ ] Embeddings: Qdrant `session_intents` collection\n\n**Success Criteria**:\n- Intent classification accuracy > 85%\n- Trajectory states still work (backward compatible)\n- Status line shows enhanced state (trajectory + intent)\n\n---\n\n### Phase 3: Continuous Knowledge Extraction (Weeks 5-6)\n**Goal**: Extract knowledge in real-time, not just batch\n\n**Components**:\n- [ ] `StreamingKnowledgeExtractor` agent (new)\n- [ ] `KnowledgeStreamBuffer` (buffering + clustering)\n- [ ] Tool interaction hook integration\n- [ ] Real-time observation storage (Qdrant + DuckDB)\n\n**Integration**:\n- Subscribe to PostToolUse hooks\n- Buffer observations (10 observations OR 5 minutes)\n- Cluster related observations\n- Store in databases\n\n**Success Criteria**:\n- Observations captured within 1 second of tool interaction\n- Clustering groups related observations (>0.85 similarity)\n- No blocking of developer workflow (async processing)\n\n---\n\n### Phase 4: Concept Generalization (Weeks 7-9)\n**Goal**: Generalize patterns into reusable concepts\n\n**Components**:\n- [ ] `ConceptAbstractionAgent` (new)\n- [ ] Enhance `DeduplicationAgent` with Qdrant similarity\n- [ ] Weekly generalization workflow\n- [ ] Concept hierarchy in Qdrant\n\n**Processing**:\n- Group similar observations (Qdrant semantic search)\n- Generate concepts via UnifiedInferenceEngine\n- Create hierarchy (Specific ‚Üí Pattern ‚Üí Concept ‚Üí Principle)\n- Deduplicate and merge\n\n**Success Criteria**:\n- Abstraction ratio > 0.3 (generalized concepts / observations)\n- Semantic deduplication > 85% accuracy\n- Concepts include all required fields (implementations, tradeoffs, pitfalls)\n\n---\n\n### Phase 5: Temporal Knowledge Management (Weeks 10-11)\n**Goal**: Track knowledge freshness, prevent stale recommendations\n\n**Components**:\n- [ ] `KnowledgeDecayTracker` (freshness scoring)\n- [ ] Temporal edges in Qdrant (supersedes, evolved_from)\n- [ ] DuckDB temporal queries\n- [ ] Search prioritization by freshness\n\n**Processing**:\n- Monthly decay detection (mark aging/stale)\n- Create deprecation links where applicable\n- Prioritize fresh knowledge in search results\n- Support temporal queries (\"auth patterns in 2024\")\n\n**Success Criteria**:\n- Freshness score > 70% (knowledge validated in last 90 days)\n- Temporal queries work (DuckDB performance < 1s)\n- Stale recommendations show warnings\n\n---\n\n### Phase 6: Database Migration & VKB Adaptation (Weeks 12-13)\n**Goal**: Migrate JSON to databases, adapt VKB visualization\n\n**Components**:\n- [ ] `migrate-json-to-databases.js` script\n- [ ] VKB visualization reads from Qdrant + DuckDB\n- [ ] Node formatting per database schema\n- [ ] Validation and testing\n\n**Migration Process**:\n1. Backup existing JSON files\n2. Parse and transform to database schema\n3. Bulk insert to Qdrant + DuckDB\n4. Validate counts and spot-check samples\n5. Test VKB visualization with database backend\n6. Decommission JSON files (after 1 month dual-read validation)\n\n**Success Criteria**:\n- All knowledge migrated (0 data loss)\n- VKB visualization works with databases\n- Performance acceptable (queries < 500ms)\n\n---\n\n## 10. ACCEPTANCE CRITERIA SUMMARY\n\n### Critical Must-Haves (Phase 1-3)\n- [ ] UnifiedInferenceEngine shared by all components (no duplicate code)\n- [ ] Budget tracking enforces $100/year limit\n- [ ] Privacy detection routes sensitive data to local models\n- [ ] Intent classification added to trajectory system\n- [ ] Continuous knowledge extraction from tool interactions\n- [ ] Agent-agnostic caching replaces MCP Memory\n\n### Important Features (Phase 4-5)\n- [ ] Concept generalization from patterns\n- [ ] Temporal knowledge management (freshness tracking)\n- [ ] Deduplication with semantic similarity\n- [ ] Cross-project knowledge sharing\n\n### Nice-to-Haves (Phase 6+)\n- [ ] VKB visualization reading from databases\n- [ ] Proactive recommendations (future)\n- [ ] Advanced analytics dashboard (future)\n\n---\n\n## 11. COMPLIANCE & CONSTRAINTS\n\n### Budget Compliance\n- [ ] Monthly spend tracked in DuckDB\n- [ ] Alert at 80% of $8.33/month limit\n- [ ] Automatic fallback to local models when budget exceeded\n- [ ] Cost breakdown by operation type\n\n### Privacy Compliance\n- [ ] Sensitive data never sent to remote LLMs\n- [ ] Audit log of all remote inference calls\n- [ ] Configuration-driven sensitivity detection\n- [ ] Fail-safe: block remote if local unavailable\n\n### Performance Compliance\n- [ ] All SLAs met (see NFR-1)\n- [ ] Dashboard monitoring with alerts\n- [ ] Degradation gracefully (no blocking)\n\n### Agent-Agnostic Compliance\n- [ ] Works with any CLI-based coding agent\n- [ ] No MCP-specific dependencies (except compatibility layer)\n- [ ] Generic caching solution\n- [ ] Documentation for agent integration\n\n---\n\n## 12. DEPENDENCIES\n\n### External Dependencies\n- [ ] **Qdrant**: Vector database (already integrated)\n- [ ] **DuckDB**: Analytical database (add new)\n- [ ] **Ollama**: Local LLM orchestrator (CODER dev containers)\n- [ ] **Groq API**: Remote inference (llama-3.3-70b, qwen-2.5-32b)\n- [ ] **Anthropic API**: Fallback inference (claude-3-haiku)\n\n### Internal Dependencies\n- [ ] **LSL System**: 5-layer classification, tool hooks\n- [ ] **Trajectory System**: RealTimeTrajectoryAnalyzer\n- [ ] **Constraint Monitor**: Violation data, budget integration\n- [ ] **MCP Semantic Analysis**: Existing agents, workflows\n- [ ] **VKB System**: Visualization, CLI commands\n\n---\n\n## 13. GLOSSARY\n\n**Agentic RAG**: Multi-agent Retrieval-Augmented Generation system with specialized agents (Librarian, Analyst, Scout)\n\n**Concept**: Generalized pattern abstracted from specific observations (e.g., \"Stateless Authentication Pattern\")\n\n**Dev Container**: Docker container in AWS/CODER with Ollama for local model inference\n\n**Intent**: Developer's current goal (learning, debugging, feature-development, etc.)\n\n**LSL**: Live Session Logging - real-time transcript monitoring system with 5-layer classification\n\n**Observation**: Single unit of extracted knowledge from development activity\n\n**Pattern**: Specific implementation of a solution (e.g., \"JWT authentication in nano-degree\")\n\n**Trajectory**: Developer's current state (exploring, implementing, verifying, etc.)\n\n**UnifiedInferenceEngine**: Shared LLM inference component used by all knowledge management features\n\n**VKB**: Visualize Knowledge Base - graph visualization of knowledge relationships\n\n---\n\n## APPROVAL CHECKLIST\n\nBefore approving this requirements specification, verify:\n\n- [ ] Business requirements align with goals (cross-project learning, budget compliance)\n- [ ] User stories cover key workflows (intent-aware extraction, cross-project discovery)\n- [ ] Functional requirements are complete and testable\n- [ ] Non-functional requirements include performance, cost, privacy, reliability\n- [ ] Technical constraints are acknowledged (reuse existing, Qdrant+DuckDB, Ollama)\n- [ ] Integration points identified for all existing systems\n- [ ] Success metrics defined with measurable targets\n- [ ] Risks identified with mitigation strategies\n- [ ] Open questions resolved\n- [ ] Implementation phases are realistic\n- [ ] Dependencies listed and available\n\n---\n\n**Document Status**: DRAFT - Awaiting User Approval\n**Next Phase**: Design (technical architecture, API contracts, database schemas)\n**Approval Method**: Spec-workflow dashboard or VS Code extension (NOT verbal)\n\n---\n\n*This requirements specification follows the spec-workflow process. After approval, the Design phase will create detailed technical architecture, API contracts, and database schemas. The Tasks phase will then break down the design into implementation tasks with specific prompts and success criteria.*\n",
  "fileStats": {
    "size": 53040,
    "lines": 1342,
    "lastModified": "2025-10-18T17:22:40.357Z"
  },
  "comments": []
}