{
  "entities": [
    {
      "name": "CodingKnowledge",
      "entityType": "System",
      "observations": [
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Central hub for high-value, transferable programming patterns"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Contains only proven solutions applicable across multiple projects"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Focus: architectural decisions, performance patterns, reusable designs"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.603Z",
        "last_updated": "2025-06-18T15:33:31.309Z"
      }
    },
    {
      "name": "ConditionalLoggingPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "NEVER console.log - ALWAYS Logger.log(level, category, message)",
          "date": "2025-06-19T11:09:12Z"
        },
        {
          "type": "implementation",
          "content": "Logger.log(\"debug\", \"component\", \"User action\", data)",
          "date": "2025-06-19T11:09:12Z"
        },
        {
          "type": "levels",
          "content": "5 levels: debug, info, warn, error, fatal",
          "date": "2025-06-19T11:09:12Z"
        },
        {
          "type": "categories",
          "content": "13 categories: auth, api, component, validation, performance, error, etc.",
          "date": "2025-06-19T11:09:12Z"
        },
        {
          "type": "features",
          "content": "Runtime filtering, persistent config, zero performance impact when disabled",
          "date": "2025-06-19T11:09:12Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ConditionalLoggingPattern.md",
          "date": "2025-06-19T11:09:12Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:09:12Z"
      },
      "quick_reference": {
        "trigger": "Any logging need in JavaScript/TypeScript projects",
        "action": "Logger.log(level, category, message) - never console methods",
        "avoid": "console.log, console.warn, console.error, console.debug",
        "check": "grep -r \"console\\.\" --include=\"*.js\" --include=\"*.ts\" . (should return nothing)"
      }
    },
    {
      "name": "ViewportCullingPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Apply viewport culling when rendering 200+ 3D objects, use advanced techniques for 800+ objects",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "basic_implementation",
          "content": "camera.position.distanceTo(object.position) < threshold",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "advanced_implementation",
          "content": "Balanced marker-centric culling: protected zone around marker (maxEvents/4), proportional left-right removal, stride-based thinning",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "performance",
          "content": "Basic: 200 objects → ~20-50 visible, <10 FPS → 60 FPS. Advanced: 75-90% reduction in rendered objects",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "anti_jump",
          "content": "Advanced pattern prevents visual jumping with protected zones and gradual object removal",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "applicability",
          "content": "Essential for any 3D scene with many objects - Three.js, React Three Fiber, timeline visualizations",
          "date": "2025-06-19T12:34:22Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ViewportCullingPattern.md",
          "date": "2025-06-19T12:34:22Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T12:34:22Z"
      },
      "quick_reference": {
        "trigger": "Rendering 200+ 3D objects causing performance issues (basic) or 800+ objects with visual jumping (advanced)",
        "action": "Basic: camera.position.distanceTo(object.position) < threshold. Advanced: balanced marker-centric culling with anti-jump algorithm",
        "avoid": "Rendering all objects regardless of visibility, naive culling without performance testing, visual jumping during culling",
        "check": "Basic: 60 FPS with 200+ objects. Advanced: 75-90% reduction in rendered objects, smooth 60fps with 800+ objects"
      }
    },
    {
      "name": "ReduxStateManagementPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "NEVER useState for complex state - ALWAYS Redux slices with typed hooks",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "basic_implementation",
          "content": "const value = useSelector(state => state.feature.value); dispatch(action())",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "architecture",
          "content": "Feature-based slices: ui, timeline, preferences, repository, logging",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "advanced_mvi",
          "content": "For 20+ components: Model-View-Intent architecture with Redux store + 5 slices + 4 intent files for async operations",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "benefits",
          "content": "Predictable state, time-travel debugging, persistence integration. Advanced: zero prop drilling, full TypeScript coverage",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "trigger_criteria",
          "content": "Basic: 15+ components, cross-component state. Advanced: 20+ components with state management chaos",
          "date": "2025-06-19T12:34:40Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ReduxStateManagementPattern.md",
          "date": "2025-06-19T12:34:40Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T12:34:40Z"
      },
      "quick_reference": {
        "trigger": "React component with complex state (3+ properties, cross-component sharing, or 20+ components)",
        "action": "Use Redux Toolkit with createSlice() and typed hooks. For large apps (20+ components): implement MVI architecture with intent layers",
        "avoid": "useState for complex state, prop drilling, direct state mutation, mixed state management approaches",
        "check": "Basic: minimal useState usage. Advanced: zero prop drilling, 100% TypeScript coverage, predictable state flow"
      }
    },
    {
      "name": "KnowledgePersistencePattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "NEVER edit shared-memory.json directly - ALWAYS use ukb command",
          "date": "2025-06-19T11:09:50Z"
        },
        {
          "type": "implementation",
          "content": "ukb --interactive for insights, ukb --add-entity for patterns, ukb --add-relation for connections",
          "date": "2025-06-19T11:09:50Z"
        },
        {
          "type": "validation",
          "content": "ukb ensures proper formatting, validation, and MCP synchronization",
          "date": "2025-06-19T11:09:50Z"
        },
        {
          "type": "workflow",
          "content": "Git-tracked JSON + MCP runtime + visualization sync",
          "date": "2025-06-19T11:09:50Z"
        },
        {
          "type": "benefits",
          "content": "Cross-session persistence, agent-agnostic design, team collaboration",
          "date": "2025-06-19T11:09:50Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/KnowledgePersistencePattern.md",
          "date": "2025-06-19T11:09:50Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:09:50Z"
      },
      "quick_reference": {
        "trigger": "Need to update knowledge base or capture insights",
        "action": "Use ukb command - never edit shared-memory.json directly",
        "avoid": "Direct JSON editing, manual file manipulation, bypassing ukb validation",
        "check": "git log --oneline -n 5 shared-memory.json (should show ukb commits only)"
      }
    },
    {
      "name": "Timeline",
      "entityType": "Project",
      "observations": [
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "3D timeline visualization with React + Three.js"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Implemented viewport culling and Redux state management patterns"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Source of multiple transferable performance and architecture patterns"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-18T15:33:31.309Z"
      }
    },
    {
      "name": "Coding",
      "entityType": "Project",
      "observations": [
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "metric",
          "content": "Coding knowledge management system for development teams"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Implements MCP persistence and cross-platform installation patterns"
        },
        {
          "date": "2025-06-06T10:00:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Automated capture and visualization of programming insights"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-18T15:33:31.309Z"
      }
    },
    {
      "name": "NetworkAwareInstallationPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Always implement network-aware detection with graceful fallbacks for enterprise environments",
          "date": "2025-06-19T11:10:37Z"
        },
        {
          "type": "implementation",
          "content": "Network detection patterns, timeout-based operations, selective repository mirroring",
          "date": "2025-06-19T11:10:37Z"
        },
        {
          "type": "applicability",
          "content": "Enterprise development tools, CI/CD systems, developer onboarding scripts",
          "date": "2025-06-19T11:10:37Z"
        },
        {
          "type": "significance",
          "content": "9/10 - Critical for enterprise software deployment",
          "date": "2025-06-19T11:10:37Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/NetworkAwareInstallationPattern.md",
          "date": "2025-06-19T11:10:37Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:10:37Z"
      },
      "quick_reference": {
        "trigger": "Installation failing in corporate networks with proxies/SSH restrictions",
        "action": "Implement network detection with timeout-based fallbacks and graceful degradation",
        "avoid": "Hard-coded network assumptions, single-point-of-failure installs, no timeout handling",
        "check": "Test installation in corporate network environment with proxies enabled"
      }
    },
    {
      "name": "DynArch",
      "entityType": "Project",
      "observations": [
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Complex autonomous driving system visualization with 7V5R processor architecture"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "metric",
          "content": "Real-time animation of sensor data flow, processing, and timing diagrams"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Origin of the sophisticated ConditionalLoggingPattern with dual-axis filtering"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Advanced timing visualization system with interactive elements"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Modular routing system for different sensor types (Camera, Radar, LiDAR)"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "insight",
          "content": "Performance-optimized animation pipeline handling complex state transitions"
        },
        {
          "date": "2025-06-08T15:30:00Z",
          "metadata": {},
          "type": "metric",
          "content": "Comprehensive documentation with UML diagrams and architectural patterns"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-18T15:33:31.309Z"
      }
    },
    {
      "name": "StateDrivenAnimationPipelinePattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Use single coordinated animation loop for 15+ simultaneous components",
          "date": "2025-06-19T11:22:19Z"
        },
        {
          "type": "implementation",
          "content": "Standardized lifecycle with requestAnimationFrame coordination and event-driven state management",
          "date": "2025-06-19T11:22:19Z"
        },
        {
          "type": "performance",
          "content": "Maintains 60fps with complex processor and sensor animations",
          "date": "2025-06-19T11:22:19Z"
        },
        {
          "type": "features",
          "content": "Dynamic registration/unregistration, graceful error handling, async task tracking",
          "date": "2025-06-19T11:22:19Z"
        },
        {
          "type": "applicability",
          "content": "Any system requiring coordinated animation management",
          "date": "2025-06-19T11:22:19Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/StateDrivenAnimationPipelinePattern.md",
          "date": "2025-06-19T11:22:19Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:22:19Z"
      },
      "quick_reference": {
        "trigger": "Need to coordinate 15+ simultaneous animation components",
        "action": "Implement standardized lifecycle: initialize → start → pause → stop → destroy with single requestAnimationFrame loop",
        "avoid": "Multiple uncoordinated animation loops, missing error handling, lack of graceful cleanup",
        "check": "Verify 60fps maintenance with complex animations and proper component registration/cleanup"
      }
    },
    {
      "name": "StrategyBasedModularRoutingPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Use strategy pattern for multiple routing algorithms with runtime registration",
          "date": "2025-06-19T11:23:27Z"
        },
        {
          "type": "implementation",
          "content": "Extensible architecture with specialized algorithms: curved paths, obstacle avoidance, boundary calculations",
          "date": "2025-06-19T11:23:27Z"
        },
        {
          "type": "performance",
          "content": "Handles 50+ simultaneous connections, <5ms simple routes, <20ms complex routes",
          "date": "2025-06-19T11:23:27Z"
        },
        {
          "type": "features",
          "content": "Dynamic boundary calculations, collision detection, configuration-driven behavior",
          "date": "2025-06-19T11:23:27Z"
        },
        {
          "type": "applicability",
          "content": "Network visualization, circuit design, game pathfinding",
          "date": "2025-06-19T11:23:27Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/StrategyBasedModularRoutingPattern.md",
          "date": "2025-06-19T11:23:27Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:23:27Z"
      },
      "quick_reference": {
        "trigger": "Need multiple routing algorithms for different connection types (50+ connections)",
        "action": "Implement strategy pattern with runtime registration and extensible architecture",
        "avoid": "Hard-coded routing logic, single routing algorithm for all cases, performance bottlenecks",
        "check": "Route calculation <5ms simple routes, <20ms complex avoidance routes"
      }
    },
    {
      "name": "MCPMemoryLoggingIntegrationPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Implement mode-aware logging for different input/output contexts with MCP sync",
          "date": "2025-06-19T11:23:43Z"
        },
        {
          "type": "implementation",
          "content": "Detect interactive vs piped mode, adjust logging accordingly, verify MCP memory sync",
          "date": "2025-06-19T11:23:43Z"
        },
        {
          "type": "insight",
          "content": "Interactive mode needs different logging approach than piped mode",
          "date": "2025-06-19T11:23:43Z"
        },
        {
          "type": "applicability",
          "content": "Any AI-assisted development system with MCP integration",
          "date": "2025-06-19T11:23:43Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/MCPMemoryLoggingIntegrationPattern.md",
          "date": "2025-06-19T11:23:43Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:23:43Z"
      },
      "quick_reference": {
        "trigger": "AI system with MCP integration failing in interactive vs piped mode",
        "action": "Implement mode-aware logging with MCP memory sync verification",
        "avoid": "Single-mode logging assumptions, missing sync verification, interactive mode hangs",
        "check": "Test both interactive and piped modes, verify MCP memory persistence"
      }
    },
    {
      "name": "UKBComprehensiveAnalysisPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Use UKB multi-mode analysis for comprehensive codebase understanding and team knowledge transfer",
          "date": "2025-06-19T11:24:00Z"
        },
        {
          "type": "implementation",
          "content": "Git history mining, conversation analysis, schema management, pattern extraction",
          "date": "2025-06-19T11:24:00Z"
        },
        {
          "type": "modes",
          "content": "Incremental (default), Full History, Interactive, Agent-assisted analysis",
          "date": "2025-06-19T11:24:00Z"
        },
        {
          "type": "benefits",
          "content": "70% faster onboarding, comprehensive technical debt assessment, data-driven architecture reviews",
          "date": "2025-06-19T11:24:00Z"
        },
        {
          "type": "scale",
          "content": "Handles repositories with 10,000+ commits, 90% time savings on subsequent runs",
          "date": "2025-06-19T11:24:00Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/UKBComprehensiveAnalysisPattern.md",
          "date": "2025-06-19T11:24:00Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-16T13:46:12.604Z",
        "last_updated": "2025-06-19T11:24:00Z"
      },
      "quick_reference": {
        "trigger": "Need comprehensive codebase understanding and knowledge transfer (10,000+ commits)",
        "action": "Use multi-mode analysis: incremental (default), full history, interactive, agent-assisted",
        "avoid": "Manual knowledge extraction, single-mode analysis, ignoring git history insights",
        "check": "70% faster onboarding, 90% time savings on subsequent runs, comprehensive technical debt assessment"
      }
    },
    {
      "name": "VSCodeExtensionBridgePattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "type": "rule",
          "content": "Integrate knowledge management directly into IDE to eliminate context switching",
          "date": "2025-06-19T11:24:14Z"
        },
        {
          "type": "implementation",
          "content": "VSCode extension with GitHub Copilot chat participant @km, HTTP API client, WebSocket for real-time updates",
          "date": "2025-06-19T11:24:14Z"
        },
        {
          "type": "performance",
          "content": "Seamless knowledge capture with <500ms response time and real-time notifications",
          "date": "2025-06-19T11:24:14Z"
        },
        {
          "type": "applicability",
          "content": "Any IDE-based developer tool integration requiring chat interfaces",
          "date": "2025-06-19T11:24:14Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/VSCodeExtensionBridgePattern.md",
          "date": "2025-06-19T11:24:14Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:24:14Z"
      },
      "quick_reference": {
        "trigger": "Context switching between IDE and knowledge management tools disrupts development flow",
        "action": "Implement native IDE integration through GitHub Copilot chat participant with HTTP API client",
        "avoid": "External tool switching, manual knowledge capture outside IDE, context disruption",
        "check": "Seamless knowledge capture with <500ms response time and real-time notifications"
      }
    },
    {
      "name": "MVIReduxArchitecturePattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "problem",
          "content": "Complex React applications with 20+ components suffer from state management chaos, prop drilling, and unpredictable updates"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "solution",
          "content": "Implement Model-View-Intent (MVI) architecture using Redux Toolkit with separate slices and intent layers"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "implementation",
          "content": "Redux store with 5 slices (ui, timeline, preferences, repository, logging) and 4 intent files handling async operations"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "benefit",
          "content": "Zero prop drilling, predictable state updates, time-travel debugging, and 100% TypeScript coverage"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/MVIReduxArchitecturePattern.md"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:25:14Z"
      },
      "quick_reference": {
        "trigger": "React app with 20+ components suffering from state management chaos",
        "action": "Implement MVI architecture using Redux Toolkit with separate slices and intent layers",
        "avoid": "Prop drilling, unpredictable state updates, mixed state management approaches",
        "check": "Zero prop drilling, 100% TypeScript coverage, predictable state flow"
      }
    },
    {
      "name": "ViewportCullingOptimizationPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "problem",
          "content": "Rendering 800+ 3D timeline events causes performance degradation below 60fps and visual jumping"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "solution",
          "content": "Implement balanced marker-centric viewport culling with anti-jump algorithm"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "implementation",
          "content": "Protected zone around marker (maxEvents/4), proportional left-right removal, stride-based thinning"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "performance",
          "content": "75-90% reduction in rendered objects while maintaining smooth 60fps"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ViewportCullingPattern.md"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:25:29Z"
      },
      "quick_reference": {
        "trigger": "Rendering 800+ 3D objects causing performance degradation below 60fps",
        "action": "Implement balanced marker-centric viewport culling with anti-jump algorithm",
        "avoid": "Naive culling causing visual jumping, rendering all objects regardless of visibility",
        "check": "75-90% reduction in rendered objects while maintaining smooth 60fps"
      }
    },
    {
      "name": "ReactThreeFiberIntegrationPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "problem",
          "content": "Need to integrate Three.js 3D graphics with React component lifecycle and state management"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "solution",
          "content": "Use React Three Fiber for declarative 3D scene management with React patterns"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "implementation",
          "content": "Canvas wrapper with hooks, refs for Three.js objects, and React event handling"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "benefit",
          "content": "Seamless integration of 3D graphics with React's declarative paradigm"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ReactThreeFiberIntegrationPattern.md"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:25:29Z"
      },
      "quick_reference": {
        "trigger": "Need to integrate Three.js 3D graphics with React component lifecycle",
        "action": "Use React Three Fiber for declarative 3D scene management with React patterns",
        "avoid": "Manual Three.js integration, bypassing React lifecycle, imperative 3D code",
        "check": "Seamless integration of 3D graphics with React's declarative paradigm"
      }
    },
    {
      "name": "ModularComponentArchitecturePattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "problem",
          "content": "Component organization becomes chaotic in large React applications"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "solution",
          "content": "Feature-based component organization with clear domain boundaries"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "implementation",
          "content": "components/three/, components/layout/, components/ui/ structure"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "metric",
          "content": "27 components organized in logical directories with zero circular dependencies"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/ModularComponentArchitecturePattern.md"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:25:29Z"
      },
      "quick_reference": {
        "trigger": "Component organization becoming chaotic in large React applications",
        "action": "Implement feature-based component organization with clear domain boundaries",
        "avoid": "Flat component structure, unclear boundaries, circular dependencies",
        "check": "Zero circular dependencies, logical directory structure, clear domain separation"
      }
    },
    {
      "name": "CustomHookExtractionPattern",
      "entityType": "TransferablePattern",
      "observations": [
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "problem",
          "content": "Duplicated stateful logic across multiple components"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "solution",
          "content": "Extract common logic into reusable custom hooks"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "implementation",
          "content": "useViewportFiltering, useTimelineAnimation, useCameraControl hooks"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "benefit",
          "content": "DRY principle applied to React hooks with full TypeScript support"
        },
        {
          "date": "2025-06-17T16:26:18Z",
          "metadata": {
            "source": "semantic-codebase-analysis"
          },
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/CustomHookExtractionPattern.md"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-18T15:17:44.017Z",
        "last_updated": "2025-06-19T11:25:29Z"
      },
      "quick_reference": {
        "trigger": "Duplicated stateful logic across multiple React components",
        "action": "Extract common logic into reusable custom hooks with TypeScript support",
        "avoid": "Duplicated component logic, inline complex state management, non-reusable patterns",
        "check": "DRY principle applied with full TypeScript support and reusable hooks"
      }
    },
    {
      "name": "CodingWorkflow",
      "entityType": "WorkflowPattern",
      "observations": [
        {
          "type": "checklist",
          "content": "1. Use claude-mcp 2. Query existing patterns 3. Start vkb visualization 4. Follow logging/state rules",
          "date": "2025-06-19T11:11:34Z"
        },
        {
          "type": "critical_rules",
          "content": "NEVER console.log, NEVER edit shared-memory.json, NEVER useState for complex state, ALWAYS use ukb",
          "date": "2025-06-19T11:11:34Z"
        },
        {
          "type": "workflow",
          "content": "Session start → Pattern queries → Development → Knowledge capture → Git sharing",
          "date": "2025-06-19T11:11:34Z"
        },
        {
          "type": "tools",
          "content": "ukb (auto/interactive/agent), vkb (start/stop/status), MCP memory sync",
          "date": "2025-06-19T11:11:34Z"
        },
        {
          "type": "compliance",
          "content": "Redux for React complex state, Logger for all output, ukb for knowledge management",
          "date": "2025-06-19T11:11:34Z"
        },
        {
          "type": "link",
          "content": "Details: http://localhost:8080/knowledge-management/insights/CodingWorkflow.md",
          "date": "2025-06-19T11:11:34Z"
        }
      ],
      "significance": 5,
      "problem": {},
      "solution": {},
      "metadata": {
        "created_at": "2025-06-19T06:40:00Z",
        "last_updated": "2025-06-19T11:11:34Z"
      },
      "quick_reference": {
        "trigger": "Starting any coding session or implementing new features",
        "action": "Follow startup checklist: check patterns, verify compliance, capture insights",
        "avoid": "console.log, direct JSON editing, skipping pattern queries, useState for complex state",
        "check": "Use agent-startup-checklist.md for session initialization"
      }
    }
  ],
  "relations": [
    {
      "from": "CodingKnowledge",
      "to": "ConditionalLoggingPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "ViewportCullingPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "ReduxStateManagementPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "KnowledgePersistencePattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "NetworkAwareInstallationPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "StateDrivenAnimationPipelinePattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "StrategyBasedModularRoutingPattern",
      "relationType": "contains"
    },
    {
      "from": "ConditionalLoggingPattern",
      "to": "DynArch",
      "relationType": "originally developed in"
    },
    {
      "from": "ConditionalLoggingPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "ViewportCullingPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "ReduxStateManagementPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "KnowledgePersistencePattern",
      "to": "Coding",
      "relationType": "implemented in"
    },
    {
      "from": "NetworkAwareInstallationPattern",
      "to": "Coding",
      "relationType": "implemented in"
    },
    {
      "from": "Timeline",
      "to": "CodingKnowledge",
      "relationType": "contributed patterns to"
    },
    {
      "from": "Coding",
      "to": "CodingKnowledge",
      "relationType": "contributed patterns to"
    },
    {
      "from": "DynArch",
      "to": "CodingKnowledge",
      "relationType": "contributed patterns to"
    },
    {
      "from": "StateDrivenAnimationPipelinePattern",
      "to": "DynArch",
      "relationType": "implemented in"
    },
    {
      "from": "StrategyBasedModularRoutingPattern",
      "to": "DynArch",
      "relationType": "implemented in"
    },
    {
      "from": "CodingKnowledge",
      "to": "MCPMemoryLoggingIntegrationPattern",
      "relationType": "contains"
    },
    {
      "from": "MCPMemoryLoggingIntegrationPattern",
      "to": "Coding",
      "relationType": "implemented in"
    },
    {
      "from": "CodingKnowledge",
      "to": "UKBComprehensiveAnalysisPattern",
      "relationType": "contains"
    },
    {
      "from": "UKBComprehensiveAnalysisPattern",
      "to": "Coding",
      "relationType": "implemented in"
    },
    {
      "from": "UKBComprehensiveAnalysisPattern",
      "to": "KnowledgePersistencePattern",
      "relationType": "enhances"
    },
    {
      "from": "CodingKnowledge",
      "to": "VSCodeExtensionBridgePattern",
      "relationType": "contains"
    },
    {
      "from": "VSCodeExtensionBridgePattern",
      "to": "MCPMemoryLoggingIntegrationPattern",
      "relationType": "extends"
    },
    {
      "from": "VSCodeExtensionBridgePattern",
      "to": "KnowledgePersistencePattern",
      "relationType": "enhances"
    },
    {
      "from": "VSCodeExtensionBridgePattern",
      "to": "UKBComprehensiveAnalysisPattern",
      "relationType": "integrates_with"
    },
    {
      "from": "CodingKnowledge",
      "to": "MVIReduxArchitecturePattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "ViewportCullingOptimizationPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "ReactThreeFiberIntegrationPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "CustomHookExtractionPattern",
      "relationType": "contains"
    },
    {
      "from": "CodingKnowledge",
      "to": "ModularComponentArchitecturePattern",
      "relationType": "contains"
    },
    {
      "from": "VSCodeExtensionBridgePattern",
      "to": "Coding",
      "relationType": "implemented in"
    },
    {
      "from": "CustomHookExtractionPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "ModularComponentArchitecturePattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "MVIReduxArchitecturePattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "ReactThreeFiberIntegrationPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "from": "ViewportCullingOptimizationPattern",
      "to": "Timeline",
      "relationType": "implemented in"
    },
    {
      "type": "relation",
      "from": "CodingWorkflow",
      "relationType": "implemented in",
      "to": "Coding",
      "created": "2025-06-19T06:40:01Z"
    },
    {
      "from": "CodingKnowledge",
      "to": "CodingWorkflow",
      "relationType": "contains"
    }
  ],
  "metadata": {
    "version": "2.0.0",
    "created": "2025-06-06T10:00:00Z",
    "last_updated": "2025-06-19T12:34:40Z",
    "contributors": [
      "agent-q284340",
      "q284340"
    ],
    "total_entities": 20,
    "total_relations": 40,
    "source": "curated_high_value_patterns",
    "last_mode": "observation_addition",
    "schema_version": "2.0.0",
    "cleanup_performed": "2025-06-18T15:57:54.158Z",
    "garbage_removal_performed": "2025-06-18T15:57:54.115Z"
  }
}
