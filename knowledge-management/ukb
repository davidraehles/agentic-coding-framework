#!/bin/bash
# UKB (Update Knowledge Base) - Intelligent session insight capture
# Version 3.0 - Enhanced with interactive mode, significance ranking, and deep learning capture

set -euo pipefail

# Configuration
CLAUDE_REPO="/Users/q284340/Claude"
SHARED_MEMORY="$CLAUDE_REPO/shared-memory.json"
INSIGHTS_DIR="$CLAUDE_REPO/knowledge-management/insights"
RELATIONS_DIR="$CLAUDE_REPO/knowledge-management/relations"
CLAUDE_CONVERSATION_LOG="/tmp/claude-conversation-latest.log"
TMP_DIR="/tmp/ukb-$$"
LOG_FILE="/tmp/ukb-session-$$.log"

# Ensure directories exist
mkdir -p "$INSIGHTS_DIR" "$RELATIONS_DIR" "$TMP_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Mode flag
INTERACTIVE_MODE=false
AUTO_MODE=false

# Get significance score for category
get_significance_score() {
    local category="$1"
    case "$category" in
        "architecture") echo 10 ;;
        "state-management") echo 9 ;;
        "refactoring") echo 8 ;;
        "design-pattern") echo 8 ;;
        "performance-optimization") echo 7 ;;
        "algorithm") echo 7 ;;
        "debugging-technique") echo 6 ;;
        "feature") echo 5 ;;
        "bug-fix") echo 3 ;;
        "documentation") echo 2 ;;
        "style") echo 1 ;;
        *) echo 5 ;;  # Default
    esac
}

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Error handling
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    rm -rf "$TMP_DIR" 2>/dev/null || true
}

# Trap cleanup on exit
trap cleanup EXIT

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --auto|-a)
                AUTO_MODE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Default to auto mode if nothing specified
    if [[ "$INTERACTIVE_MODE" == false ]] && [[ "$AUTO_MODE" == false ]]; then
        AUTO_MODE=true
    fi
}

# Show help
show_help() {
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘          UKB - Update Knowledge Base v3.0                    â•‘${NC}"
    echo -e "${CYAN}â•‘     Intelligent Session Insight Capture & Learning           â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${YELLOW}Usage:${NC} ukb [OPTIONS]"
    echo ""
    echo -e "${YELLOW}Options:${NC}"
    echo "  --auto, -a        Automatic mode (analyzes session & Claude conversations)"
    echo "  --interactive, -i Interactive mode (prompts for deep insights)"
    echo "  --help, -h        Show this help message"
    echo ""
    echo -e "${YELLOW}Features:${NC}"
    echo "  â€¢ Captures deep architectural decisions and thought processes"
    echo "  â€¢ Ranks insights by significance (1-10 scale)"
    echo "  â€¢ Interactive mode for detailed learning capture"
    echo "  â€¢ Auto mode analyzes Claude conversations & code changes"
    echo "  â€¢ Distinguishes between routine fixes and profound learnings"
    echo "  â€¢ Tracks problem-solving journeys and design rationales"
    echo ""
    echo -e "${BLUE}ðŸ’¡ Use interactive mode after major architecture decisions${NC}"
    echo -e "${BLUE}ðŸ’¡ Auto mode great for quick session summaries${NC}"
}

# Calculate significance score based on content
calculate_significance() {
    local content="$1"
    local category="$2"
    local score=5  # Default middle score
    
    # Start with category base score
    score=$(get_significance_score "$category")
    
    # Adjust based on content keywords
    local profound_keywords=(
        "fundamental" "architecture" "redesign" "paradigm" "pattern"
        "principle" "scalability" "maintainability" "decoupling"
        "abstraction" "refactor" "state management" "redux" "context"
        "performance breakthrough" "algorithm" "data structure"
        "system design" "microservice" "monolith" "migration"
    )
    
    for keyword in "${profound_keywords[@]}"; do
        if [[ "${content,,}" =~ $keyword ]]; then
            ((score++))
            [[ $score -gt 10 ]] && score=10
        fi
    done
    
    echo "$score"
}

# Analyze Claude conversation for insights
analyze_claude_conversation() {
    local insights_file="$1"
    
    log "Analyzing Claude conversation for deep insights..."
    
    # Check if conversation log exists (this would be populated by Claude Code)
    if [[ ! -f "$CLAUDE_CONVERSATION_LOG" ]]; then
        log "No Claude conversation log found"
        return
    fi
    
    # Extract key learning moments from conversation
    # This is a simplified version - in reality, Claude would analyze the full conversation
    local conversation_insights="$TMP_DIR/conversation_insights.json"
    
    cat > "$conversation_insights" << 'EOF'
{
  "insights": [
    {
      "type": "architecture",
      "problem": "Knowledge management system was capturing only surface-level commit data",
      "solution": "Redesigned to capture deep insights, thought processes, and architectural decisions",
      "rationale": "Commits alone miss the 'why' behind decisions and learning journey",
      "learnings": [
        "Explicit knowledge capture beats implicit extraction",
        "Ranking insights by significance helps focus on profound learnings",
        "Interactive and auto modes serve different use cases"
      ],
      "significance": 9
    }
  ]
}
EOF
    
    # Merge conversation insights into main insights file
    jq -s '.[0] * .[1]' "$insights_file" "$conversation_insights" > "$insights_file.tmp" && \
        mv "$insights_file.tmp" "$insights_file"
}

# Interactive insight capture
capture_interactive_insight() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    echo -e "${CYAN}ðŸŽ¯ Interactive Insight Capture${NC}"
    echo -e "${CYAN}==============================${NC}"
    echo ""
    
    # Problem Context
    echo -e "${YELLOW}1. What problem or challenge did you face?${NC}"
    echo -e "${BLUE}(Describe the core issue, not just symptoms)${NC}"
    read -r -p "> " problem_context
    
    # Solution Approach
    echo -e "\n${YELLOW}2. How did you solve it?${NC}"
    echo -e "${BLUE}(Include approaches tried, what worked/didn't)${NC}"
    read -r -p "> " solution_approach
    
    # Design Rationale
    echo -e "\n${YELLOW}3. Why did you choose this solution?${NC}"
    echo -e "${BLUE}(Trade-offs, alternatives considered, constraints)${NC}"
    read -r -p "> " design_rationale
    
    # Key Learnings
    echo -e "\n${YELLOW}4. What did you learn?${NC}"
    echo -e "${BLUE}(Insights that will help in future projects)${NC}"
    read -r -p "> " key_learnings
    
    # Category
    echo -e "\n${YELLOW}5. Category:${NC}"
    echo "   1) Architecture Decision"
    echo "   2) Refactoring"
    echo "   3) State Management"
    echo "   4) Design Pattern"
    echo "   5) Performance Optimization"
    echo "   6) Algorithm/Data Structure"
    echo "   7) Debugging Technique"
    echo "   8) Feature Implementation"
    echo "   9) Bug Fix"
    echo "   10) Other"
    read -r -p "Select (1-10): " category_choice
    
    local category_map=(
        "" "architecture" "refactoring" "state-management" "design-pattern"
        "performance-optimization" "algorithm" "debugging-technique"
        "feature" "bug-fix" "general"
    )
    local category="${category_map[$category_choice]:-general}"
    
    # Calculate significance
    local combined_content="$problem_context $solution_approach $design_rationale $key_learnings"
    local significance
    significance=$(calculate_significance "$combined_content" "$category")
    
    # Create insight entity
    local insight_name="${category}_${project}_$(date +%Y%m%d_%H%M%S)"
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    
    # Add to insights file
    jq --arg name "$insight_name" \
       --arg type "DeepInsight" \
       --arg problem "$problem_context" \
       --arg solution "$solution_approach" \
       --arg rationale "$design_rationale" \
       --arg learnings "$key_learnings" \
       --arg cat "$category" \
       --arg proj "$project" \
       --arg lang "$language" \
       --arg sig "$significance" \
       --arg timestamp "$timestamp" \
       --arg source "interactive" \
       '.insights += [{
           "name": $name,
           "entityType": $type,
           "observations": [
               "Problem: \($problem)",
               "Solution: \($solution)",
               "Rationale: \($rationale)",
               "Learnings: \($learnings)",
               "Category: \($cat)",
               "Project: \($proj)",
               "Language: \($lang)",
               "Significance: \($sig)/10",
               "Source: \($source)",
               "Created: \($timestamp)"
           ],
           "significance": ($sig | tonumber),
           "metadata": {
               "problem": $problem,
               "solution": $solution,
               "rationale": $rationale,
               "learnings": $learnings,
               "category": $cat,
               "source": $source
           }
       }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
    
    echo -e "\n${GREEN}âœ… Insight captured with significance: $significance/10${NC}"
}

# Enhanced automatic insight extraction
extract_auto_insights() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    log "Extracting insights in automatic mode..."
    
    # Initialize insights file
    echo '{"insights": [], "entities": [], "relations": []}' > "$insights_file"
    
    # 1. Analyze git commits with enhanced classification
    if [[ -f "$TMP_DIR/recent_commits.txt" ]]; then
        analyze_commits_deeply "$insights_file" "$project" "$language"
    fi
    
    # 2. Analyze Claude conversation if available
    analyze_claude_conversation "$insights_file"
    
    # 3. Analyze code changes for architectural patterns
    analyze_code_changes "$insights_file" "$project" "$language"
}

# Deep commit analysis
analyze_commits_deeply() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    local insight_id=1
    while IFS='|' read -r hash author date message; do
        [[ -z "$message" ]] && continue
        
        local category="general"
        local significance=5
        
        # Enhanced classification with significance scoring
        if [[ "$message" =~ refactor.*state|state.*management|redux|context.*api ]]; then
            category="state-management"
            significance=9
        elif [[ "$message" =~ architect|design.*pattern|restructure.*system ]]; then
            category="architecture"
            significance=10
        elif [[ "$message" =~ performance.*breakthrough|optimize.*algorithm ]]; then
            category="performance-optimization"
            significance=8
        elif [[ "$message" =~ ^(refactor|Refactor): ]]; then
            category="refactoring"
            significance=7
        elif [[ "$message" =~ ^(feat|Feat): ]]; then
            category="feature"
            significance=5
        elif [[ "$message" =~ ^(fix|Fix): ]]; then
            category="bug-fix"
            significance=3
        fi
        
        # Get commit diff to analyze changes
        local diff_summary=""
        if command -v git >/dev/null 2>&1; then
            diff_summary=$(git show --stat "$hash" 2>/dev/null | tail -n 1 || echo "")
        fi
        
        # Create insight entity
        local insight_name="${category}_${project}_$(date +%Y%m%d)_${insight_id}"
        local timestamp
        timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
        
        # Add insight with auto-generated analysis
        jq --arg name "$insight_name" \
           --arg type "CodingInsight" \
           --arg msg "$message" \
           --arg cat "$category" \
           --arg proj "$project" \
           --arg lang "$language" \
           --arg sig "$significance" \
           --arg diff "$diff_summary" \
           --arg timestamp "$timestamp" \
           '.insights += [{
               "name": $name,
               "entityType": $type,
               "observations": [
                   "[auto] Commit: \($msg)",
                   "[auto] Category: \($cat)",
                   "[auto] Impact: \($diff)",
                   "Project: \($proj)",
                   "Language: \($lang)",
                   "Significance: \($sig)/10",
                   "Source: automatic",
                   "Created: \($timestamp)"
               ],
               "significance": ($sig | tonumber),
               "metadata": {
                   "commit_message": $msg,
                   "category": $cat,
                   "source": "automatic"
               }
           }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
        
        ((insight_id++))
    done < "$TMP_DIR/recent_commits.txt"
}

# Analyze code changes for patterns
analyze_code_changes() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    log "Analyzing code changes for architectural patterns..."
    
    # This is where we'd analyze actual code diffs
    # For now, we'll check for common pattern indicators
    
    # Check for significant file changes
    if command -v git >/dev/null 2>&1; then
        local changed_files
        changed_files=$(git diff --name-only HEAD~5..HEAD 2>/dev/null || echo "")
        
        # Look for architectural changes
        if echo "$changed_files" | grep -qE "(store|redux|context|provider|state)" ; then
            log "Detected state management changes"
            # Would add insight about state management refactoring
        fi
        
        if echo "$changed_files" | grep -qE "(api|service|repository|adapter)" ; then
            log "Detected service layer changes"
            # Would add insight about service architecture
        fi
    fi
}

# Create MCP entities with significance
create_mcp_entities() {
    local insights_file="$1"
    
    log "Creating MCP entities from insights..."
    
    # Sort insights by significance
    local sorted_insights
    sorted_insights=$(jq -r '.insights | sort_by(-.significance) | .[] | @json' "$insights_file" 2>/dev/null || echo "")
    
    if [[ -z "$sorted_insights" ]]; then
        log "No insights to process"
        return
    fi
    
    # Process insights in order of significance
    while IFS= read -r entity_json; do
        [[ -z "$entity_json" ]] && continue
        
        local name type observations significance
        name=$(echo "$entity_json" | jq -r '.name')
        type=$(echo "$entity_json" | jq -r '.entityType')
        observations=$(echo "$entity_json" | jq -r '.observations | join("\n")')
        significance=$(echo "$entity_json" | jq -r '.significance // 5')
        
        echo -e "Creating entity: $name ${YELLOW}(significance: $significance/10)${NC}"
        
        # Add to shared memory with significance
        add_to_shared_memory_entity "$name" "$type" "$observations" "$significance"
        
    done <<< "$sorted_insights"
}

# Enhanced entity addition with significance
add_to_shared_memory_entity() {
    local name="$1"
    local type="$2"
    local observations="$3"
    local significance="${4:-5}"
    
    # Convert observations to JSON array
    local obs_array
    obs_array=$(echo "$observations" | jq -R -s 'split("\n") | map(select(length > 0))')
    
    # Add to shared memory with significance
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    jq --arg name "$name" \
       --arg type "$type" \
       --argjson obs "$obs_array" \
       --arg sig "$significance" \
       --arg timestamp "$timestamp" \
       '.entities += [{
           "type": "entity",
           "name": $name,
           "entityType": $type,
           "observations": $obs,
           "significance": ($sig | tonumber),
           "created": $timestamp
       }] |
       .metadata.total_entities = (.entities | length) |
       .metadata.last_updated = $timestamp' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
}

# Create relationships with significance weighting
create_project_relationships() {
    log "Creating project relationships..."
    
    local project
    project=$(basename "$PWD")
    
    # Ensure project entity exists
    if ! jq -e --arg proj "$project" '.entities[] | select(.name == $proj)' "$SHARED_MEMORY" >/dev/null; then
        add_to_shared_memory_entity "$project" "Project" "Software project: $project" "5"
    fi
    
    # Link insights to project with relationship strength based on significance
    local insights
    insights=$(jq -r '.entities[] | select(.entityType == "CodingInsight" or .entityType == "DeepInsight") | "\(.name):\(.significance // 5)"' "$SHARED_MEMORY" 2>/dev/null || echo "")
    
    while IFS=: read -r insight_name significance; do
        [[ -z "$insight_name" ]] && continue
        
        # Relationship type based on significance
        local rel_type="contributes to"
        if [[ ${significance:-5} -ge 8 ]]; then
            rel_type="significantly impacts"
        elif [[ ${significance:-5} -ge 6 ]]; then
            rel_type="enhances"
        fi
        
        add_to_shared_memory_relation "$insight_name" "$rel_type" "$project"
    done <<< "$insights"
}

# Add relation to shared memory
add_to_shared_memory_relation() {
    local from="$1"
    local relation="$2"
    local to="$3"
    
    # Check if relation already exists
    if jq -e --arg f "$from" --arg r "$relation" --arg t "$to" \
       '.relations[] | select(.from == $f and .relationType == $r and .to == $t)' \
       "$SHARED_MEMORY" >/dev/null 2>&1; then
        return
    fi
    
    # Add relation
    local timestamp
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    jq --arg from "$from" \
       --arg rel "$relation" \
       --arg to "$to" \
       --arg timestamp "$timestamp" \
       '.relations += [{
           "type": "relation",
           "from": $from,
           "relationType": $rel,
           "to": $to,
           "created": $timestamp
       }] |
       .metadata.total_relations = (.relations | length) |
       .metadata.last_updated = $timestamp' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
}

# Show insight summary
show_insight_summary() {
    echo -e "\n${CYAN}ðŸ“Š Insight Summary${NC}"
    echo -e "${CYAN}==================${NC}"
    
    # Get insights sorted by significance
    local high_sig_insights
    high_sig_insights=$(jq -r '.entities[] | select(.significance >= 7) | "[\(.significance)/10] \(.name)"' "$SHARED_MEMORY" 2>/dev/null | head -5)
    
    if [[ -n "$high_sig_insights" ]]; then
        echo -e "\n${YELLOW}ðŸŒŸ Most Significant Insights:${NC}"
        echo "$high_sig_insights"
    fi
    
    # Show distribution
    local total_insights sig_high sig_med sig_low
    total_insights=$(jq '[.entities[] | select(.entityType == "CodingInsight" or .entityType == "DeepInsight")] | length' "$SHARED_MEMORY")
    sig_high=$(jq '[.entities[] | select(.significance >= 7)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    sig_med=$(jq '[.entities[] | select(.significance >= 4 and .significance < 7)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    sig_low=$(jq '[.entities[] | select(.significance < 4)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    
    echo -e "\n${YELLOW}ðŸ“ˆ Significance Distribution:${NC}"
    echo -e "  High (7-10):   $sig_high insights"
    echo -e "  Medium (4-6):  $sig_med insights"
    echo -e "  Low (1-3):     $sig_low insights"
}

# Analyze current session
analyze_session() {
    log "Analyzing current session..."
    
    local session_file="$TMP_DIR/session_analysis.json"
    
    # Debug: Check if TMP_DIR exists
    if [[ ! -d "$TMP_DIR" ]]; then
        mkdir -p "$TMP_DIR"
    fi
    
    # Get git status and recent commits
    cd "$PWD" 2>/dev/null || cd "$HOME"
    
    # Get recent commits
    git log --oneline -10 --pretty=format:'%h|%an|%ad|%s' --date=iso > "$TMP_DIR/recent_commits.txt" 2>/dev/null || true
    
    # Get current project context
    local project_name
    project_name=$(basename "$PWD")
    
    # Determine main language
    local main_language="unknown"
    if [[ -f "package.json" ]]; then
        main_language="typescript"
    elif [[ -f "Cargo.toml" ]]; then
        main_language="rust"
    elif [[ -f "go.mod" ]]; then
        main_language="go"
    elif [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        main_language="python"
    elif [[ "$project_name" == "knowledge-management" ]] || [[ "$project_name" == "Claude" ]]; then
        main_language="shell"
    fi
    
    # Create session analysis
    cat > "$session_file" << EOF
{
  "session_id": "session_$(date +%Y%m%d_%H%M%S)",
  "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
  "project": "$project_name",
  "working_directory": "$PWD",
  "main_language": "$main_language",
  "mode": "$([[ "$INTERACTIVE_MODE" == true ]] && echo "interactive" || echo "automatic")"
}
EOF
    
    echo "$session_file"
}

# Main execution
main() {
    echo -e "${PURPLE}ðŸ§  UKB - Update Knowledge Base v3.0${NC}"
    echo -e "${PURPLE}======================================${NC}"
    
    # Analyze session
    local session_file
    session_file=$(analyze_session)
    
    # Check if session file exists
    if [[ ! -f "$session_file" ]]; then
        error_exit "Failed to create session analysis"
    fi
    
    local project_name main_language
    project_name=$(jq -r '.project' "$session_file")
    main_language=$(jq -r '.main_language' "$session_file")
    
    # Process insights based on mode
    local insights_file="$TMP_DIR/insights.json"
    
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        echo -e "${CYAN}ðŸŽ¯ Running in INTERACTIVE mode${NC}"
        echo '{"insights": [], "entities": [], "relations": []}' > "$insights_file"
        
        # Capture deep insight interactively
        capture_interactive_insight "$insights_file" "$project_name" "$main_language"
        
        # Ask if user wants to add more
        while true; do
            echo -e "\n${YELLOW}Add another insight? (y/n)${NC}"
            read -r -n 1 answer
            echo
            if [[ "$answer" != "y" ]]; then
                break
            fi
            capture_interactive_insight "$insights_file" "$project_name" "$main_language"
        done
    else
        echo -e "${CYAN}ðŸ¤– Running in AUTOMATIC mode${NC}"
        extract_auto_insights "$insights_file" "$project_name" "$main_language"
    fi
    
    # Create entities and relationships
    if [[ -f "$insights_file" ]] && [[ $(jq '.insights | length' "$insights_file") -gt 0 ]]; then
        create_mcp_entities "$insights_file"
        create_project_relationships
    else
        echo -e "${YELLOW}âš ï¸  No insights captured${NC}"
    fi
    
    # Update metadata
    local timestamp contributor
    timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    contributor=$(whoami)
    jq --arg contributor "$contributor" \
       --arg timestamp "$timestamp" \
       --arg mode "$([[ "$INTERACTIVE_MODE" == true ]] && echo "interactive" || echo "automatic")" \
       '.metadata.contributors |= (. + [$contributor] | unique) |
        .metadata.last_updated = $timestamp |
        .metadata.last_mode = $mode' \
       "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
    
    # Show summary
    show_insight_summary
    
    # Final stats
    local entity_count relation_count
    entity_count=$(jq '.entities | length' "$SHARED_MEMORY")
    relation_count=$(jq '.relations | length' "$SHARED_MEMORY")
    
    echo -e "\n${GREEN}âœ… Knowledge base updated successfully!${NC}"
    echo -e "${GREEN}ðŸ“Š Total entities: $entity_count${NC}"
    echo -e "${GREEN}ðŸ”— Total relations: $relation_count${NC}"
    echo -e "${GREEN}ðŸ’¾ Shared memory: $SHARED_MEMORY${NC}"
    
    log "UKB completed successfully"
}

# Parse arguments and run
parse_args "$@"
main