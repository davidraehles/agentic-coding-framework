#!/bin/bash
# UKB Enhanced - Update Knowledge Base with structured observations
# Version 4.0 - Enhanced entity structure with typed observations

set -euo pipefail

# Configuration - Dynamic repo detection
find_repo_root() {
    local current_dir="$PWD"
    while [[ "$current_dir" != "/" ]]; do
        if [[ -f "$current_dir/shared-memory.json" ]] && [[ -d "$current_dir/knowledge-management" ]]; then
            echo "$current_dir"
            return 0
        fi
        current_dir="$(dirname "$current_dir")"
    done
    
    if [[ -f "/Users/q284340/Agentic/coding/shared-memory.json" ]]; then
        echo "/Users/q284340/Agentic/coding"
        return 0
    fi
    
    echo "/Users/q284340/Agentic/coding"  # Default fallback
}

CLAUDE_REPO="$(find_repo_root)"
SHARED_MEMORY="$CLAUDE_REPO/shared-memory.json"
INSIGHTS_DIR="$CLAUDE_REPO/knowledge-management/insights"
TMP_DIR="/tmp/ukb-$$"
LOG_FILE="/tmp/ukb-session-$$.log"

# Ensure directories exist
mkdir -p "$INSIGHTS_DIR" "$TMP_DIR"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Mode flag
INTERACTIVE_MODE=false
AUTO_MODE=false
MIGRATE_MODE=false

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Error handling
error_exit() {
    echo -e "${RED}ERROR: $1${NC}" >&2
    cleanup
    exit 1
}

# Cleanup function
cleanup() {
    rm -rf "$TMP_DIR" 2>/dev/null || true
}

# Trap cleanup on exit
trap cleanup EXIT

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --interactive|-i)
                INTERACTIVE_MODE=true
                shift
                ;;
            --auto|-a)
                AUTO_MODE=true
                shift
                ;;
            --migrate|-m)
                MIGRATE_MODE=true
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                echo "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    # Default to auto mode if nothing specified
    if [[ "$INTERACTIVE_MODE" == false ]] && [[ "$AUTO_MODE" == false ]] && [[ "$MIGRATE_MODE" == false ]]; then
        AUTO_MODE=true
    fi
}

# Show help
show_help() {
    echo -e "${CYAN}â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—${NC}"
    echo -e "${CYAN}â•‘          UKB Enhanced - Update Knowledge Base v4.0           â•‘${NC}"
    echo -e "${CYAN}â•‘     Structured Observations & Enhanced Entity Format         â•‘${NC}"
    echo -e "${CYAN}â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""
    echo -e "${YELLOW}Usage:${NC} ukb [OPTIONS]"
    echo ""
    echo -e "${YELLOW}Options:${NC}"
    echo "  --auto, -a        Automatic mode (analyzes recent changes)"
    echo "  --interactive, -i Interactive mode (structured insight capture)"
    echo "  --migrate, -m     Migrate existing entities to new format"
    echo "  --help, -h        Show this help message"
    echo ""
    echo -e "${YELLOW}Features:${NC}"
    echo "  â€¢ Structured observations (problem, solution, metric, etc.)"
    echo "  â€¢ Enhanced metadata tracking (usage count, last used)"
    echo "  â€¢ Code snippet extraction and embedding"
    echo "  â€¢ Pattern verification and compliance checking"
    echo "  â€¢ Backward compatibility with legacy format"
    echo ""
}

# Extract code snippet from file
extract_code_snippet() {
    local file_path="$1"
    local pattern="${2:-}"
    local context_lines=5
    
    if [[ ! -f "$file_path" ]]; then
        echo ""
        return
    fi
    
    if [[ -n "$pattern" ]]; then
        # Extract around pattern match
        grep -A "$context_lines" -B "$context_lines" "$pattern" "$file_path" 2>/dev/null | head -20 || echo ""
    else
        # Extract key section (look for class/function definitions)
        grep -E "^(class |function |def |const |export |public )" "$file_path" -A 10 2>/dev/null | head -20 || echo ""
    fi
}

# Capture structured interactive insight
capture_structured_insight() {
    local insights_file="$1"
    local project="$2"
    local language="$3"
    
    echo -e "${CYAN}ðŸŽ¯ Structured Insight Capture${NC}"
    echo -e "${CYAN}=============================${NC}"
    echo ""
    
    # Pattern name
    echo -e "${YELLOW}1. Pattern Name (e.g., ConditionalLoggingPattern):${NC}"
    read -r -p "> " pattern_name
    [[ -z "$pattern_name" ]] && pattern_name="Pattern_$(date +%s)"
    
    # Problem structure
    echo -e "\n${YELLOW}2. Problem Description:${NC}"
    read -r -p "> " problem_desc
    
    echo -e "\n${YELLOW}3. Problem Symptoms (comma-separated):${NC}"
    echo -e "${BLUE}(e.g., slow performance, memory leaks, complex code)${NC}"
    read -r -p "> " problem_symptoms
    
    echo -e "\n${YELLOW}4. Problem Impact (critical/high/medium/low):${NC}"
    read -r -p "> " problem_impact
    [[ -z "$problem_impact" ]] && problem_impact="medium"
    
    # Solution structure
    echo -e "\n${YELLOW}5. Solution Approach:${NC}"
    read -r -p "> " solution_approach
    
    echo -e "\n${YELLOW}6. Implementation Details:${NC}"
    read -r -p "> " solution_implementation
    
    echo -e "\n${YELLOW}7. Key Code File (for snippet extraction):${NC}"
    read -r -p "> " key_code_file
    
    # Extract code snippet if file provided
    local code_example=""
    if [[ -n "$key_code_file" ]] && [[ -f "$key_code_file" ]]; then
        echo -e "${BLUE}Extracting code snippet...${NC}"
        code_example=$(extract_code_snippet "$key_code_file")
        if [[ -n "$code_example" ]]; then
            echo -e "${GREEN}âœ“ Code snippet extracted${NC}"
        fi
    fi
    
    # Context structure
    echo -e "\n${YELLOW}8. Applicable Contexts (comma-separated):${NC}"
    echo -e "${BLUE}(e.g., web apps, microservices, real-time systems)${NC}"
    read -r -p "> " applicability
    
    echo -e "\n${YELLOW}9. Technologies (comma-separated):${NC}"
    read -r -p "> " technologies
    
    echo -e "\n${YELLOW}10. Performance Impact (optional):${NC}"
    echo -e "${BLUE}Before:${NC}"
    read -r -p "> " perf_before
    echo -e "${BLUE}After:${NC}"
    read -r -p "> " perf_after
    
    echo -e "\n${YELLOW}11. Complexity (trivial/simple/moderate/complex/expert):${NC}"
    read -r -p "> " complexity
    [[ -z "$complexity" ]] && complexity="moderate"
    
    # References
    echo -e "\n${YELLOW}12. Related Patterns (comma-separated, optional):${NC}"
    read -r -p "> " related_patterns
    
    echo -e "\n${YELLOW}13. External References (URLs, comma-separated, optional):${NC}"
    read -r -p "> " external_refs
    
    # Calculate significance
    local significance=5
    case "$problem_impact" in
        "critical") significance=9 ;;
        "high") significance=8 ;;
        "medium") significance=6 ;;
        "low") significance=4 ;;
    esac
    
    # Adjust based on complexity
    case "$complexity" in
        "expert") ((significance++)) ;;
        "complex") ((significance++)) ;;
    esac
    [[ $significance -gt 10 ]] && significance=10
    
    # Build structured entity
    local timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
    local author=$(whoami)
    
    # Process arrays
    local symptoms_array=$(echo "$problem_symptoms" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R -s 'split("\n") | map(select(length > 0))')
    local applicability_array=$(echo "$applicability" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R -s 'split("\n") | map(select(length > 0))')
    local technologies_array=$(echo "$technologies" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R -s 'split("\n") | map(select(length > 0))')
    local related_array=$(echo "$related_patterns" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R -s 'split("\n") | map(select(length > 0))')
    local refs_array=$(echo "$external_refs" | tr ',' '\n' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//' | jq -R -s 'split("\n") | map(select(length > 0))')
    
    # Build performance object
    local perf_obj="{}"
    [[ -n "$perf_before" ]] && perf_obj=$(echo "$perf_obj" | jq --arg before "$perf_before" '.before = $before')
    [[ -n "$perf_after" ]] && perf_obj=$(echo "$perf_obj" | jq --arg after "$perf_after" '.after = $after')
    
    # Create structured observations
    local observations_array=$(jq -n \
        --arg prob "$problem_desc" \
        --arg sol "$solution_approach" \
        --arg impl "$solution_implementation" \
        --arg sig "$significance" \
        --arg timestamp "$timestamp" \
        '[
            {"type": "problem", "content": $prob, "date": $timestamp},
            {"type": "solution", "content": $sol, "date": $timestamp},
            {"type": "insight", "content": $impl, "date": $timestamp},
            {"type": "metric", "content": "Significance: \($sig)/10", "date": $timestamp}
        ]')
    
    # Add code example if available
    if [[ -n "$code_example" ]]; then
        observations_array=$(echo "$observations_array" | jq \
            --arg code "$code_example" \
            --arg timestamp "$timestamp" \
            '. + [{"type": "code_example", "content": $code, "date": $timestamp}]')
    fi
    
    # Add entity to insights file
    jq --arg name "$pattern_name" \
       --arg type "TransferablePattern" \
       --arg prob_desc "$problem_desc" \
       --argjson prob_symptoms "$symptoms_array" \
       --arg prob_impact "$problem_impact" \
       --arg sol_approach "$solution_approach" \
       --arg sol_impl "$solution_implementation" \
       --arg sol_code "$code_example" \
       --argjson applicability "$applicability_array" \
       --argjson technologies "$technologies_array" \
       --argjson performance "$perf_obj" \
       --arg complexity "$complexity" \
       --argjson related "$related_array" \
       --argjson external "$refs_array" \
       --arg author "$author" \
       --arg project "$project" \
       --arg sig "$significance" \
       --arg timestamp "$timestamp" \
       --argjson observations "$observations_array" \
       '.insights += [{
           "name": $name,
           "entityType": $type,
           "metadata": {
               "significance": ($sig | tonumber),
               "author": $author,
               "project": $project,
               "created": $timestamp,
               "last_used": null,
               "usage_count": 0
           },
           "problem": {
               "description": $prob_desc,
               "symptoms": $prob_symptoms,
               "impact": $prob_impact
           },
           "solution": {
               "approach": $sol_approach,
               "implementation": $sol_impl,
               "code_example": $sol_code
           },
           "context": {
               "applicability": $applicability,
               "technologies": $technologies,
               "performance": $performance,
               "complexity": $complexity
           },
           "references": {
               "code_files": (if $sol_code then [$project] else [] end),
               "documentation": null,
               "external": $external,
               "related_patterns": $related
           },
           "observations": $observations
       }]' "$insights_file" > "$insights_file.tmp" && mv "$insights_file.tmp" "$insights_file"
    
    echo -e "\n${GREEN}âœ… Structured insight captured (significance: $significance/10)${NC}"
}

# Add enhanced entity to shared memory
add_enhanced_entity() {
    local entity_json="$1"
    
    local name=$(echo "$entity_json" | jq -r '.name')
    local entityType=$(echo "$entity_json" | jq -r '.entityType')
    
    echo "  Adding enhanced entity: $name"
    
    # Check if entity exists
    if jq -e --arg name "$name" '.entities[] | select(.name == $name)' "$SHARED_MEMORY" >/dev/null 2>&1; then
        # Update existing entity
        jq --arg name "$name" \
           --argjson entity "$entity_json" \
           --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
           '(.entities[] | select(.name == $name)) = $entity |
            .metadata.last_updated = $timestamp' \
           "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
    else
        # Add new entity
        jq --argjson entity "$entity_json" \
           --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
           '.entities += [$entity] |
            .metadata.total_entities = (.entities | length) |
            .metadata.last_updated = $timestamp' \
           "$SHARED_MEMORY" > "$SHARED_MEMORY.tmp" && mv "$SHARED_MEMORY.tmp" "$SHARED_MEMORY"
    fi
}

# Process insights and add to shared memory
process_enhanced_insights() {
    local insights_file="$1"
    
    echo -e "${CYAN}ðŸ“Š Processing enhanced insights...${NC}"
    
    # Get all insights
    local insights=$(jq -c '.insights[]' "$insights_file" 2>/dev/null)
    
    while IFS= read -r insight; do
        [[ -z "$insight" ]] && continue
        add_enhanced_entity "$insight"
    done <<< "$insights"
}

# Main execution
main() {
    echo -e "${PURPLE}ðŸ§  UKB Enhanced - Update Knowledge Base v4.0${NC}"
    echo -e "${PURPLE}============================================${NC}"
    
    # Handle migration mode
    if [[ "$MIGRATE_MODE" == true ]]; then
        echo -e "${CYAN}ðŸ”„ Running migration...${NC}"
        node "$CLAUDE_REPO/knowledge-management/scripts/migrate-entities.js"
        exit 0
    fi
    
    # Process insights based on mode
    local insights_file="$TMP_DIR/insights.json"
    local project=$(basename "$PWD")
    local language="unknown"
    
    # Detect language
    if [[ -f "package.json" ]]; then
        language="typescript"
    elif [[ -f "Cargo.toml" ]]; then
        language="rust"
    elif [[ -f "go.mod" ]]; then
        language="go"
    elif [[ -f "pyproject.toml" ]] || [[ -f "requirements.txt" ]]; then
        language="python"
    fi
    
    if [[ "$INTERACTIVE_MODE" == true ]]; then
        echo -e "${CYAN}ðŸŽ¯ Running in INTERACTIVE mode${NC}"
        echo '{"insights": []}' > "$insights_file"
        
        # Capture structured insight
        capture_structured_insight "$insights_file" "$project" "$language"
        
        # Ask if user wants to add more
        while true; do
            echo -e "\n${YELLOW}Add another insight? (y/n)${NC}"
            read -r -n 1 answer
            echo
            if [[ "$answer" != "y" ]]; then
                break
            fi
            capture_structured_insight "$insights_file" "$project" "$language"
        done
        
        # Process insights
        process_enhanced_insights "$insights_file"
    else
        echo -e "${CYAN}ðŸ¤– Running in AUTOMATIC mode${NC}"
        echo -e "${YELLOW}Note: Auto mode is conservative to maintain quality${NC}"
        echo -e "${BLUE}ðŸ’¡ Use 'ukb --interactive' for detailed pattern capture${NC}"
    fi
    
    # Show summary
    local entity_count=$(jq '.entities | length' "$SHARED_MEMORY")
    local enhanced_count=$(jq '[.entities[] | select(.metadata and .problem and .solution)] | length' "$SHARED_MEMORY" 2>/dev/null || echo "0")
    
    echo -e "\n${GREEN}âœ… Knowledge base updated!${NC}"
    echo -e "${GREEN}ðŸ“Š Total entities: $entity_count${NC}"
    echo -e "${GREEN}ðŸ”§ Enhanced format: $enhanced_count${NC}"
    echo -e "${GREEN}ðŸ’¾ Location: $SHARED_MEMORY${NC}"
}

# Parse arguments and run
parse_args "$@"
main